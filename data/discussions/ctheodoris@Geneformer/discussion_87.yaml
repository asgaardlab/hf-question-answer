!!python/object:huggingface_hub.community.DiscussionWithDetails
author: as8020
conflicting_files: null
created_at: 2023-07-04 21:31:31+00:00
diff: null
endpoint: https://huggingface.co
events:
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: /avatars/87f21efa1de8510c376d8edd089563f0.svg
      fullname: Anjali Golding
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: as8020
      type: user
    createdAt: '2023-07-04T22:31:31.000Z'
    data:
      edited: false
      editors:
      - as8020
      hidden: false
      identifiedLanguage:
        language: en
        probability: 0.5609197020530701
      isReport: false
      latest:
        author:
          avatarUrl: /avatars/87f21efa1de8510c376d8edd089563f0.svg
          fullname: Anjali Golding
          isHf: false
          isPro: false
          name: as8020
          type: user
        html: "<p>Hi, will you be providing worked example code for your bivalent\
          \ chromatin section within the paper? I see that you have already provided\
          \ the data files. </p>\n<p>I am new to python and machine learning and tried\
          \ the below code by adapting the TF dosage example but ran into an issue:</p>\n\
          <h1 id=\"targets-represent-the-genes-or-gene-ids-that-the-model-will-be-trained-to-predict-or-classify-targets-are-obtained-based-on-genegroup1-and-genegroup2-inputs\"\
          >Targets represent the genes or gene IDs that the model will be trained\
          \ to predict or classify. Targets are obtained based on genegroup1 and genegroup2\
          \ inputs.</h1>\n<p>#Labels are associated with targets and indicate class/category\
          \ each target belongs.<br>#Binary labels (0 or 1) are assigned based on\
          \ whether target belongs to genegroup1 or genegroup2.<br>#nsplits determines\
          \ number of splits for cross-validation.<br>#Altered to handle three gene\
          \ groups instead</p>\n<p>def prep_inputs(genegroup1, genegroup2, genegroup3,\
          \ id_type):<br>    if id_type == \"gene_name\":<br>        targets1 = [gene_name_id_dict[gene]\
          \ for gene in genegroup1 if gene_name_id_dict.get(gene) in token_dictionary]<br>\
          \        targets2 = [gene_name_id_dict[gene] for gene in genegroup2 if gene_name_id_dict.get(gene)\
          \ in token_dictionary]<br>        targets3 = [gene_name_id_dict[gene] for\
          \ gene in genegroup3 if gene_name_id_dict.get(gene) in token_dictionary]<br>\
          \    elif id_type == \"ensembl_id\":<br>        targets1 = [gene for gene\
          \ in genegroup1 if gene in token_dictionary]<br>        targets2 = [gene\
          \ for gene in genegroup2 if gene in token_dictionary]<br>        targets3\
          \ = [gene for gene in genegroup3 if gene in token_dictionary]</p>\n<pre><code>targets1_id\
          \ = [token_dictionary[gene] for gene in targets1]\ntargets2_id = [token_dictionary[gene]\
          \ for gene in targets2]\ntargets3_id = [token_dictionary[gene] for gene\
          \ in targets3]\n\ntargets = np.array(targets1_id + targets2_id + targets3_id)\n\
          labels = np.array([0]*len(targets1_id) + [1]*len(targets2_id) + [2]*len(targets3_id))\n\
          nsplits = min(5, min(len(targets1_id), len(targets2_id), len(targets3_id))-1)\n\
          #nsplits = min(5, min(len(targets1_id), len(targets2_id), len(targets3_id),\
          \ 4))\n#nsplits = 5             \nprint(f\"# targets1: {len(targets1_id)}\\\
          n# targets2: {len(targets2_id)}\\n# targets3: {len(targets3_id)}\\n# splits:\
          \ {nsplits}\")\nreturn targets, labels, nsplits\n</code></pre>\n<p>#Preparing\
          \ targets and labels for each of the chromatin marks<br>#try 2</p>\n<p>bivalent_group\
          \ = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/bivalent_gene_labels.txt\"\
          , header=0)<br>bivalent_group = bivalent_group.dropna()<br>#<br>heading_row\
          \ = bivalent_group.iloc[0]<br>bivalent_group = bivalent_group[1:]<br>bivalent_group\
          \ = pd.concat([pd.DataFrame([heading_row], columns=bivalent_group.columns),\
          \ bivalent_group]).reset_index(drop=True)</p>\n<p>lys4_only_group = pd.read_csv(\"\
          /shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/lys4_only_gene_labels.txt\"\
          , header=0)<br>lys4_only_group = lys4_only_group.dropna()<br>#<br>heading_row\
          \ = lys4_only_group.iloc[0]<br>lys4_only_group = lys4_only_group[1:]<br>lys4_only_group\
          \ = pd.concat([pd.DataFrame([heading_row], columns=lys4_only_group.columns),\
          \ lys4_only_group]).reset_index(drop=True)</p>\n<p>no_methylation_group\
          \ = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/no_methylation_gene_labels.txt\"\
          , header=0)<br>no_methylation_group = no_methylation_group.dropna()<br>#<br>heading_row\
          \ = no_methylation_group.iloc[0]<br>no_methylation_group = no_methylation_group[1:]<br>no_methylation_group\
          \ = pd.concat([pd.DataFrame([heading_row], columns=no_methylation_group.columns),\
          \ no_methylation_group]).reset_index(drop=True)</p>\n<p>targets, labels,\
          \ nsplits = prep_inputs(bivalent_group, lys4_only_group, no_methylation_group,\
          \ \"ensembl_id\")</p>\n<p>But for some reason get this output:</p>\n<h1\
          \ id=\"targets1-1\">targets1: 1</h1>\n<h1 id=\"targets2-1\">targets2: 1</h1>\n\
          <h1 id=\"targets3-1\">targets3: 1</h1>\n<h1 id=\"splits-0\">splits: 0</h1>\n"
        raw: "Hi, will you be providing worked example code for your bivalent chromatin\
          \ section within the paper? I see that you have already provided the data\
          \ files. \r\n\r\nI am new to python and machine learning and tried the below\
          \ code by adapting the TF dosage example but ran into an issue:\r\n\r\n\r\
          \n# Targets represent the genes or gene IDs that the model will be trained\
          \ to predict or classify. Targets are obtained based on genegroup1 and genegroup2\
          \ inputs.\r\n#Labels are associated with targets and indicate class/category\
          \ each target belongs.\r\n#Binary labels (0 or 1) are assigned based on\
          \ whether target belongs to genegroup1 or genegroup2.\r\n#nsplits determines\
          \ number of splits for cross-validation.\r\n#Altered to handle three gene\
          \ groups instead\r\n\r\ndef prep_inputs(genegroup1, genegroup2, genegroup3,\
          \ id_type):\r\n    if id_type == \"gene_name\":\r\n        targets1 = [gene_name_id_dict[gene]\
          \ for gene in genegroup1 if gene_name_id_dict.get(gene) in token_dictionary]\r\
          \n        targets2 = [gene_name_id_dict[gene] for gene in genegroup2 if\
          \ gene_name_id_dict.get(gene) in token_dictionary]\r\n        targets3 =\
          \ [gene_name_id_dict[gene] for gene in genegroup3 if gene_name_id_dict.get(gene)\
          \ in token_dictionary]\r\n    elif id_type == \"ensembl_id\":\r\n      \
          \  targets1 = [gene for gene in genegroup1 if gene in token_dictionary]\r\
          \n        targets2 = [gene for gene in genegroup2 if gene in token_dictionary]\r\
          \n        targets3 = [gene for gene in genegroup3 if gene in token_dictionary]\r\
          \n            \r\n    targets1_id = [token_dictionary[gene] for gene in\
          \ targets1]\r\n    targets2_id = [token_dictionary[gene] for gene in targets2]\r\
          \n    targets3_id = [token_dictionary[gene] for gene in targets3]\r\n  \
          \  \r\n    targets = np.array(targets1_id + targets2_id + targets3_id)\r\
          \n    labels = np.array([0]*len(targets1_id) + [1]*len(targets2_id) + [2]*len(targets3_id))\r\
          \n    nsplits = min(5, min(len(targets1_id), len(targets2_id), len(targets3_id))-1)\r\
          \n    #nsplits = min(5, min(len(targets1_id), len(targets2_id), len(targets3_id),\
          \ 4))\r\n    #nsplits = 5             \r\n    print(f\"# targets1: {len(targets1_id)}\\\
          n# targets2: {len(targets2_id)}\\n# targets3: {len(targets3_id)}\\n# splits:\
          \ {nsplits}\")\r\n    return targets, labels, nsplits\r\n\r\n#Preparing\
          \ targets and labels for each of the chromatin marks\r\n#try 2\r\n\r\nbivalent_group\
          \ = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/bivalent_gene_labels.txt\"\
          , header=0)\r\nbivalent_group = bivalent_group.dropna()\r\n#\r\nheading_row\
          \ = bivalent_group.iloc[0]\r\nbivalent_group = bivalent_group[1:]\r\nbivalent_group\
          \ = pd.concat([pd.DataFrame([heading_row], columns=bivalent_group.columns),\
          \ bivalent_group]).reset_index(drop=True)\r\n\r\n\r\nlys4_only_group = pd.read_csv(\"\
          /shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/lys4_only_gene_labels.txt\"\
          , header=0)\r\nlys4_only_group = lys4_only_group.dropna()\r\n#\r\nheading_row\
          \ = lys4_only_group.iloc[0]\r\nlys4_only_group = lys4_only_group[1:]\r\n\
          lys4_only_group = pd.concat([pd.DataFrame([heading_row], columns=lys4_only_group.columns),\
          \ lys4_only_group]).reset_index(drop=True)\r\n\r\nno_methylation_group =\
          \ pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/no_methylation_gene_labels.txt\"\
          , header=0)\r\nno_methylation_group = no_methylation_group.dropna()\r\n\
          #\r\nheading_row = no_methylation_group.iloc[0]\r\nno_methylation_group\
          \ = no_methylation_group[1:]\r\nno_methylation_group = pd.concat([pd.DataFrame([heading_row],\
          \ columns=no_methylation_group.columns), no_methylation_group]).reset_index(drop=True)\r\
          \n\r\n\r\ntargets, labels, nsplits = prep_inputs(bivalent_group, lys4_only_group,\
          \ no_methylation_group, \"ensembl_id\")\r\n\r\nBut for some reason get this\
          \ output:\r\n\r\n# targets1: 1\r\n# targets2: 1\r\n# targets3: 1\r\n# splits:\
          \ 0"
        updatedAt: '2023-07-04T22:31:31.637Z'
      numEdits: 0
      reactions: []
    id: 64a49dc3f94f7fbcfbaac2a8
    type: comment
  author: as8020
  content: "Hi, will you be providing worked example code for your bivalent chromatin\
    \ section within the paper? I see that you have already provided the data files.\
    \ \r\n\r\nI am new to python and machine learning and tried the below code by\
    \ adapting the TF dosage example but ran into an issue:\r\n\r\n\r\n# Targets represent\
    \ the genes or gene IDs that the model will be trained to predict or classify.\
    \ Targets are obtained based on genegroup1 and genegroup2 inputs.\r\n#Labels are\
    \ associated with targets and indicate class/category each target belongs.\r\n\
    #Binary labels (0 or 1) are assigned based on whether target belongs to genegroup1\
    \ or genegroup2.\r\n#nsplits determines number of splits for cross-validation.\r\
    \n#Altered to handle three gene groups instead\r\n\r\ndef prep_inputs(genegroup1,\
    \ genegroup2, genegroup3, id_type):\r\n    if id_type == \"gene_name\":\r\n  \
    \      targets1 = [gene_name_id_dict[gene] for gene in genegroup1 if gene_name_id_dict.get(gene)\
    \ in token_dictionary]\r\n        targets2 = [gene_name_id_dict[gene] for gene\
    \ in genegroup2 if gene_name_id_dict.get(gene) in token_dictionary]\r\n      \
    \  targets3 = [gene_name_id_dict[gene] for gene in genegroup3 if gene_name_id_dict.get(gene)\
    \ in token_dictionary]\r\n    elif id_type == \"ensembl_id\":\r\n        targets1\
    \ = [gene for gene in genegroup1 if gene in token_dictionary]\r\n        targets2\
    \ = [gene for gene in genegroup2 if gene in token_dictionary]\r\n        targets3\
    \ = [gene for gene in genegroup3 if gene in token_dictionary]\r\n            \r\
    \n    targets1_id = [token_dictionary[gene] for gene in targets1]\r\n    targets2_id\
    \ = [token_dictionary[gene] for gene in targets2]\r\n    targets3_id = [token_dictionary[gene]\
    \ for gene in targets3]\r\n    \r\n    targets = np.array(targets1_id + targets2_id\
    \ + targets3_id)\r\n    labels = np.array([0]*len(targets1_id) + [1]*len(targets2_id)\
    \ + [2]*len(targets3_id))\r\n    nsplits = min(5, min(len(targets1_id), len(targets2_id),\
    \ len(targets3_id))-1)\r\n    #nsplits = min(5, min(len(targets1_id), len(targets2_id),\
    \ len(targets3_id), 4))\r\n    #nsplits = 5             \r\n    print(f\"# targets1:\
    \ {len(targets1_id)}\\n# targets2: {len(targets2_id)}\\n# targets3: {len(targets3_id)}\\\
    n# splits: {nsplits}\")\r\n    return targets, labels, nsplits\r\n\r\n#Preparing\
    \ targets and labels for each of the chromatin marks\r\n#try 2\r\n\r\nbivalent_group\
    \ = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/bivalent_gene_labels.txt\"\
    , header=0)\r\nbivalent_group = bivalent_group.dropna()\r\n#\r\nheading_row =\
    \ bivalent_group.iloc[0]\r\nbivalent_group = bivalent_group[1:]\r\nbivalent_group\
    \ = pd.concat([pd.DataFrame([heading_row], columns=bivalent_group.columns), bivalent_group]).reset_index(drop=True)\r\
    \n\r\n\r\nlys4_only_group = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/lys4_only_gene_labels.txt\"\
    , header=0)\r\nlys4_only_group = lys4_only_group.dropna()\r\n#\r\nheading_row\
    \ = lys4_only_group.iloc[0]\r\nlys4_only_group = lys4_only_group[1:]\r\nlys4_only_group\
    \ = pd.concat([pd.DataFrame([heading_row], columns=lys4_only_group.columns), lys4_only_group]).reset_index(drop=True)\r\
    \n\r\nno_methylation_group = pd.read_csv(\"/shared/as8020/Geneformer2/Genecorpus-30M/example_input_files/gene_classification/bivalent_promoters/no_methylation_gene_labels.txt\"\
    , header=0)\r\nno_methylation_group = no_methylation_group.dropna()\r\n#\r\nheading_row\
    \ = no_methylation_group.iloc[0]\r\nno_methylation_group = no_methylation_group[1:]\r\
    \nno_methylation_group = pd.concat([pd.DataFrame([heading_row], columns=no_methylation_group.columns),\
    \ no_methylation_group]).reset_index(drop=True)\r\n\r\n\r\ntargets, labels, nsplits\
    \ = prep_inputs(bivalent_group, lys4_only_group, no_methylation_group, \"ensembl_id\"\
    )\r\n\r\nBut for some reason get this output:\r\n\r\n# targets1: 1\r\n# targets2:\
    \ 1\r\n# targets3: 1\r\n# splits: 0"
  created_at: 2023-07-04 21:31:31+00:00
  edited: false
  hidden: false
  id: 64a49dc3f94f7fbcfbaac2a8
  type: comment
- !!python/object:huggingface_hub.community.DiscussionStatusChange
  _event:
    author:
      avatarUrl: /avatars/87f21efa1de8510c376d8edd089563f0.svg
      fullname: Anjali Golding
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: as8020
      type: user
    createdAt: '2023-07-05T10:45:03.000Z'
    data:
      status: closed
    id: 64a549af1526469ed6e1f7bf
    type: status-change
  author: as8020
  created_at: 2023-07-05 09:45:03+00:00
  id: 64a549af1526469ed6e1f7bf
  new_status: closed
  type: status-change
is_pull_request: false
merge_commit_oid: null
num: 87
repo_id: ctheodoris/Geneformer
repo_type: model
status: closed
target_branch: null
title: Bivalent chromatin example
