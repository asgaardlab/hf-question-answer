!!python/object:huggingface_hub.community.DiscussionWithDetails
author: justYeah
conflicting_files: null
created_at: 2023-08-22 07:23:19+00:00
diff: null
endpoint: https://huggingface.co
events:
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: /avatars/f903c9712a01d711d8b2c78fb0631042.svg
      fullname: changjuhao
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: justYeah
      type: user
    createdAt: '2023-08-22T08:23:19.000Z'
    data:
      edited: true
      editors:
      - justYeah
      hidden: false
      identifiedLanguage:
        language: en
        probability: 0.5375670790672302
      isReport: false
      latest:
        author:
          avatarUrl: /avatars/f903c9712a01d711d8b2c78fb0631042.svg
          fullname: changjuhao
          isHf: false
          isPro: false
          name: justYeah
          type: user
        html: "<p>\u6A21\u578B\u5B9E\u4F8B\u5316\u65F6\uFF0C\u663E\u793A \u8BF7\u6C42\
          \u8FDE\u63A5\u5931\u8D25\uFF0C\u6709\u5927\u4F6C\u53EF\u4EE5\u5E2E\u5FD9\
          \u770B\u4E0B\u8FD9\u662F\u4E3A\u4EC0\u4E48\u5417\uFF1F<br>\u5177\u4F53\u62A5\
          \u9519\u5982\u4E0B\uFF1A<br>ConnectionResetError                      Traceback\
          \ (most recent call last)<br>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)<br>    702 # Make the request on the httplib\
          \ connection object.<br>--&gt; 703 httplib_response = self._make_request(<br>\
          \    704     conn,<br>    705     method,<br>    706     url,<br>    707\
          \     timeout=timeout_obj,<br>    708     body=body,<br>    709     headers=headers,<br>\
          \    710     chunked=chunked,<br>    711 )<br>    713 # If we're going to\
          \ release the connection in <code>finally:</code>, then<br>    714 # the\
          \ response doesn't need to know about the connection. Otherwise<br>    715\
          \ # it will also try to release it and we'll have a double-release<br> \
          \   716 # mess.</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)<br>    385 try:<br>--&gt; 386     self._validate_conn(conn)<br>\
          \    387 except (SocketTimeout, BaseSSLError) as e:<br>    388     # Py2\
          \ raises this as a BaseSSLError, Py3 raises it as socket timeout.</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)<br>   1039 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  <code>.sock</code><br>-&gt;\
          \ 1040     conn.connect()<br>   1042 if not conn.is_verified:</p>\n<p>File\
          \ /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)<br>    412     context.load_default_certs()<br>--&gt;\
          \ 414 self.sock = ssl_wrap_socket(<br>    415     sock=conn,<br>    416\
          \     keyfile=self.key_file,<br>    417     certfile=self.cert_file,<br>\
          \    418     key_password=self.key_password,<br>    419     ca_certs=self.ca_certs,<br>\
          \    420     ca_cert_dir=self.ca_cert_dir,<br>    421     ca_cert_data=self.ca_cert_data,<br>\
          \    422     server_hostname=server_hostname,<br>    423     ssl_context=context,<br>\
          \    424     tls_in_tls=tls_in_tls,<br>    425 )<br>    427 # If we're using\
          \ all defaults and the connection<br>    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning<br>    429 # for the host.</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)<br>    448 if send_sni:<br>--&gt; 449     ssl_sock = _ssl_wrap_socket_impl(<br>\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname<br>\
          \    451     )<br>    452 else:</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)<br>\
          \    492 if server_hostname:<br>--&gt; 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)<br>    494 else:</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:500,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)<br>    494 def wrap_socket(self,\
          \ sock, server_side=False,<br>    495                 do_handshake_on_connect=True,<br>\
          \    496                 suppress_ragged_eofs=True,<br>    497         \
          \        server_hostname=None, session=None):<br>    498     # SSLSocket\
          \ class handles server_hostname encoding before it calls<br>    499    \
          \ # ctx._wrap_socket()<br>--&gt; 500     return self.sslsocket_class._create(<br>\
          \    501         sock=sock,<br>    502         server_side=server_side,<br>\
          \    503         do_handshake_on_connect=do_handshake_on_connect,<br>  \
          \  504         suppress_ragged_eofs=suppress_ragged_eofs,<br>    505   \
          \      server_hostname=server_hostname,<br>    506         context=self,<br>\
          \    507         session=session<br>    508     )</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:1040,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)<br>   1039  \
          \           raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")<br>-&gt; 1040         self.do_handshake()<br>\
          \   1041 except (OSError, ValueError):</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:1309,\
          \ in SSLSocket.do_handshake(self, block)<br>   1308         self.settimeout(None)<br>-&gt;\
          \ 1309     self._sslobj.do_handshake()<br>   1310 finally:</p>\n<p>ConnectionResetError:\
          \ [Errno 104] Connection reset by peer</p>\n<p>During handling of the above\
          \ exception, another exception occurred:</p>\n<p>ProtocolError         \
          \                    Traceback (most recent call last)<br>File /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:440,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)<br>\
          \    439 if not chunked:<br>--&gt; 440     resp = conn.urlopen(<br>    441\
          \         method=request.method,<br>    442         url=url,<br>    443\
          \         body=request.body,<br>    444         headers=request.headers,<br>\
          \    445         redirect=False,<br>    446         assert_same_host=False,<br>\
          \    447         preload_content=False,<br>    448         decode_content=False,<br>\
          \    449         retries=self.max_retries,<br>    450         timeout=timeout<br>\
          \    451     )<br>    453 # Send the request.<br>    454 else:</p>\n<p>File\
          \ /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:785,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)<br>    783     e = ProtocolError(\"Connection\
          \ aborted.\", e)<br>--&gt; 785 retries = retries.increment(<br>    786 \
          \    method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]<br>\
          \    787 )<br>    788 retries.sleep()</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
          \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)<br>\
          \    549 if read is False or not self._is_method_retryable(method):<br>--&gt;\
          \ 550     raise six.reraise(type(error), error, _stacktrace)<br>    551\
          \ elif read is not None:</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
          \ in reraise(tp, value, tb)<br>    768 if value.<strong>traceback</strong>\
          \ is not tb:<br>--&gt; 769     raise value.with_traceback(tb)<br>    770\
          \ raise value</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)<br>    702 # Make the request on the httplib\
          \ connection object.<br>--&gt; 703 httplib_response = self._make_request(<br>\
          \    704     conn,<br>    705     method,<br>    706     url,<br>    707\
          \     timeout=timeout_obj,<br>    708     body=body,<br>    709     headers=headers,<br>\
          \    710     chunked=chunked,<br>    711 )<br>    713 # If we're going to\
          \ release the connection in <code>finally:</code>, then<br>    714 # the\
          \ response doesn't need to know about the connection. Otherwise<br>    715\
          \ # it will also try to release it and we'll have a double-release<br> \
          \   716 # mess.</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)<br>    385 try:<br>--&gt; 386     self._validate_conn(conn)<br>\
          \    387 except (SocketTimeout, BaseSSLError) as e:<br>    388     # Py2\
          \ raises this as a BaseSSLError, Py3 raises it as socket timeout.</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)<br>   1039 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  <code>.sock</code><br>-&gt;\
          \ 1040     conn.connect()<br>   1042 if not conn.is_verified:</p>\n<p>File\
          \ /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)<br>    412     context.load_default_certs()<br>--&gt;\
          \ 414 self.sock = ssl_wrap_socket(<br>    415     sock=conn,<br>    416\
          \     keyfile=self.key_file,<br>    417     certfile=self.cert_file,<br>\
          \    418     key_password=self.key_password,<br>    419     ca_certs=self.ca_certs,<br>\
          \    420     ca_cert_dir=self.ca_cert_dir,<br>    421     ca_cert_data=self.ca_cert_data,<br>\
          \    422     server_hostname=server_hostname,<br>    423     ssl_context=context,<br>\
          \    424     tls_in_tls=tls_in_tls,<br>    425 )<br>    427 # If we're using\
          \ all defaults and the connection<br>    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning<br>    429 # for the host.</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)<br>    448 if send_sni:<br>--&gt; 449     ssl_sock = _ssl_wrap_socket_impl(<br>\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname<br>\
          \    451     )<br>    452 else:</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)<br>\
          \    492 if server_hostname:<br>--&gt; 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)<br>    494 else:</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:500,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)<br>    494 def wrap_socket(self,\
          \ sock, server_side=False,<br>    495                 do_handshake_on_connect=True,<br>\
          \    496                 suppress_ragged_eofs=True,<br>    497         \
          \        server_hostname=None, session=None):<br>    498     # SSLSocket\
          \ class handles server_hostname encoding before it calls<br>    499    \
          \ # ctx._wrap_socket()<br>--&gt; 500     return self.sslsocket_class._create(<br>\
          \    501         sock=sock,<br>    502         server_side=server_side,<br>\
          \    503         do_handshake_on_connect=do_handshake_on_connect,<br>  \
          \  504         suppress_ragged_eofs=suppress_ragged_eofs,<br>    505   \
          \      server_hostname=server_hostname,<br>    506         context=self,<br>\
          \    507         session=session<br>    508     )</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:1040,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)<br>   1039  \
          \           raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")<br>-&gt; 1040         self.do_handshake()<br>\
          \   1041 except (OSError, ValueError):</p>\n<p>File /opt/anaconda3/lib/python3.9/ssl.py:1309,\
          \ in SSLSocket.do_handshake(self, block)<br>   1308         self.settimeout(None)<br>-&gt;\
          \ 1309     self._sslobj.do_handshake()<br>   1310 finally:</p>\n<p>ProtocolError:\
          \ ('Connection aborted.', ConnectionResetError(104, 'Connection reset by\
          \ peer'))</p>\n<p>During handling of the above exception, another exception\
          \ occurred:</p>\n<p>ConnectionError                           Traceback\
          \ (most recent call last)<br>Input In [29], in &lt;cell line: 5&gt;()<br>\
          \      1 # !pip install -U sentence-transformers<br>      2 # from sentence_transformers\
          \ import SentenceTransformer<br>----&gt; 5 model = SentenceTransformer('moka-ai/m3e-base')</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
          \ in SentenceTransformer.<strong>init</strong>(self, model_name_or_path,\
          \ modules, device, cache_folder, use_auth_token)<br>     83     model_path\
          \ = os.path.join(cache_folder, model_name_or_path.replace(\"/\", \"_\"))<br>\
          \     85     if not os.path.exists(os.path.join(model_path, 'modules.json')):<br>\
          \     86         # Download from hub with caching<br>---&gt; 87        \
          \ snapshot_download(model_name_or_path,<br>     88                     \
          \        cache_dir=cache_folder,<br>     89                            \
          \ library_name='sentence-transformers',<br>     90                     \
          \        library_version=<strong>version</strong>,<br>     91          \
          \                   ignore_files=['flax_model.msgpack', 'rust_model.ot',\
          \ 'tf_model.h5'],<br>     92                             use_auth_token=use_auth_token)<br>\
          \     94 if os.path.exists(os.path.join(model_path, 'modules.json')):  \
          \  #Load as SentenceTransformer model<br>     95     modules = self._load_sbert_model(model_path)</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/util.py:491,\
          \ in snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
          \ user_agent, ignore_files, use_auth_token)<br>    486 if version.parse(huggingface_hub.<strong>version</strong>)\
          \ &gt;= version.parse(\"0.8.1\"):<br>    487     # huggingface_hub v0.8.1\
          \ introduces a new cache layout. We sill use a manual layout<br>    488\
          \     # And need to pass legacy_cache_layout=True to avoid that a warning\
          \ will be printed<br>    489     cached_download_args['legacy_cache_layout']\
          \ = True<br>--&gt; 491 path = cached_download(**cached_download_args)<br>\
          \    493 if os.path.exists(path + \".lock\"):<br>    494     os.remove(path\
          \ + \".lock\")</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:118,\
          \ in validate_hf_hub_args.._inner_fn(*args, **kwargs)<br>    115 if check_use_auth_token:<br>\
          \    116     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.<strong>name</strong>,\
          \ has_token=has_token, kwargs=kwargs)<br>--&gt; 118 return fn(*args, **kwargs)</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:800,\
          \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
          \ force_download, force_filename, proxies, etag_timeout, resume_download,\
          \ token, local_files_only, legacy_cache_layout)<br>    797 with temp_file_manager()\
          \ as temp_file:<br>    798     logger.info(\"downloading %s to %s\", url,\
          \ temp_file.name)<br>--&gt; 800     http_get(<br>    801         url_to_download,<br>\
          \    802         temp_file,<br>    803         proxies=proxies,<br>    804\
          \         resume_size=resume_size,<br>    805         headers=headers,<br>\
          \    806         expected_size=expected_size,<br>    807     )<br>    809\
          \ logger.info(\"storing %s in cache at %s\", url, cache_path)<br>    810\
          \ _chmod_and_replace(temp_file.name, cache_path)</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
          \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries,\
          \ expected_size)<br>    502 if resume_size &gt; 0:<br>    503     headers[\"\
          Range\"] = \"bytes=%d-\" % (resume_size,)<br>--&gt; 505 r = _request_wrapper(<br>\
          \    506     method=\"GET\",<br>    507     url=url,<br>    508     stream=True,<br>\
          \    509     proxies=proxies,<br>    510     headers=headers,<br>    511\
          \     timeout=timeout,<br>    512     max_retries=max_retries,<br>    513\
          \ )<br>    514 hf_raise_for_status(r)<br>    515 content_length = r.headers.get(\"\
          Content-Length\")</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
          \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
          \ timeout, follow_relative_redirects, **params)<br>    439     return response<br>\
          \    441 # 3. Exponential backoff<br>--&gt; 442 return http_backoff(<br>\
          \    443     method=method,<br>    444     url=url,<br>    445     max_retries=max_retries,<br>\
          \    446     base_wait_time=base_wait_time,<br>    447     max_wait_time=max_wait_time,<br>\
          \    448     retry_on_exceptions=(Timeout, ProxyError),<br>    449     retry_on_status_codes=(),<br>\
          \    450     timeout=timeout,<br>    451     **params,<br>    452 )</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:258,\
          \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time,\
          \ retry_on_exceptions, retry_on_status_codes, **kwargs)<br>    255     kwargs[\"\
          data\"].seek(io_obj_initial_pos)<br>    257 # Perform request and return\
          \ if status_code is not in the retry list.<br>--&gt; 258 response = session.request(method=method,\
          \ url=url, **kwargs)<br>    259 if response.status_code not in retry_on_status_codes:<br>\
          \    260     return response</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:529,\
          \ in Session.request(self, method, url, params, data, headers, cookies,\
          \ files, auth, timeout, allow_redirects, proxies, hooks, stream, verify,\
          \ cert, json)<br>    524 send_kwargs = {<br>    525     'timeout': timeout,<br>\
          \    526     'allow_redirects': allow_redirects,<br>    527 }<br>    528\
          \ send_kwargs.update(settings)<br>--&gt; 529 resp = self.send(prep, **send_kwargs)<br>\
          \    531 return resp</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:645,\
          \ in Session.send(self, request, **kwargs)<br>    642 start = preferred_clock()<br>\
          \    644 # Send the request<br>--&gt; 645 r = adapter.send(request, **kwargs)<br>\
          \    647 # Total elapsed time of the request (approximately)<br>    648\
          \ elapsed = preferred_clock() - start</p>\n<p>File /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:63,\
          \ in UniqueRequestIdAdapter.send(self, request, *args, **kwargs)<br>   \
          \  61 \"\"\"Catch any RequestException to append request id to the error\
          \ message for debugging.\"\"\"<br>     62 try:<br>---&gt; 63     return\
          \ super().send(request, *args, **kwargs)<br>     64 except requests.RequestException\
          \ as e:<br>     65     request_id = request.headers.get(X_AMZN_TRACE_ID)</p>\n\
          <p>File /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:501,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)<br>\
          \    498             raise<br>    500 except (ProtocolError, socket.error)\
          \ as err:<br>--&gt; 501     raise ConnectionError(err, request=request)<br>\
          \    503 except MaxRetryError as e:<br>    504     if isinstance(e.reason,\
          \ ConnectTimeoutError):<br>    505         # TODO: Remove this in 3.0.0:\
          \ see #2811</p>\n<p>ConnectionError: (ProtocolError('Connection aborted.',\
          \ ConnectionResetError(104, 'Connection reset by peer')), '(Request ID:\
          \ ddd4ac08-2e62-424c-9563-9cb91e9d1379)')</p>\n"
        raw: "\u6A21\u578B\u5B9E\u4F8B\u5316\u65F6\uFF0C\u663E\u793A \u8BF7\u6C42\u8FDE\
          \u63A5\u5931\u8D25\uFF0C\u6709\u5927\u4F6C\u53EF\u4EE5\u5E2E\u5FD9\u770B\
          \u4E0B\u8FD9\u662F\u4E3A\u4EC0\u4E48\u5417\uFF1F\n\u5177\u4F53\u62A5\u9519\
          \u5982\u4E0B\uFF1A\nConnectionResetError                      Traceback\
          \ (most recent call last)\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    702 # Make the request on the httplib connection\
          \ object.\n--> 703 httplib_response = self._make_request(\n    704     conn,\n\
          \    705     method,\n    706     url,\n    707     timeout=timeout_obj,\n\
          \    708     body=body,\n    709     headers=headers,\n    710     chunked=chunked,\n\
          \    711 )\n    713 # If we're going to release the connection in ``finally:``,\
          \ then\n    714 # the response doesn't need to know about the connection.\
          \ Otherwise\n    715 # it will also try to release it and we'll have a double-release\n\
          \    716 # mess.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\n    385 try:\n--> 386     self._validate_conn(conn)\n\
          \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
          \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1039 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\n-> 1040     conn.connect()\n\
          \   1042 if not conn.is_verified:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
          --> 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416  \
          \   keyfile=self.key_file,\n    417     certfile=self.cert_file,\n    418\
          \     key_password=self.key_password,\n    419     ca_certs=self.ca_certs,\n\
          \    420     ca_cert_dir=self.ca_cert_dir,\n    421     ca_cert_data=self.ca_cert_data,\n\
          \    422     server_hostname=server_hostname,\n    423     ssl_context=context,\n\
          \    424     tls_in_tls=tls_in_tls,\n    425 )\n    427 # If we're using\
          \ all defaults and the connection\n    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning\n    429 # for the host.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\n    448 if send_sni:\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\n\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
          \    451     )\n    452 else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n\
          \    492 if server_hostname:\n--> 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\n    494 else:\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:500,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\n    494 def wrap_socket(self,\
          \ sock, server_side=False,\n    495                 do_handshake_on_connect=True,\n\
          \    496                 suppress_ragged_eofs=True,\n    497           \
          \      server_hostname=None, session=None):\n    498     # SSLSocket class\
          \ handles server_hostname encoding before it calls\n    499     # ctx._wrap_socket()\n\
          --> 500     return self.sslsocket_class._create(\n    501         sock=sock,\n\
          \    502         server_side=server_side,\n    503         do_handshake_on_connect=do_handshake_on_connect,\n\
          \    504         suppress_ragged_eofs=suppress_ragged_eofs,\n    505   \
          \      server_hostname=server_hostname,\n    506         context=self,\n\
          \    507         session=session\n    508     )\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1040,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\n   1039    \
          \         raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\n-> 1040         self.do_handshake()\n   1041\
          \ except (OSError, ValueError):\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1309,\
          \ in SSLSocket.do_handshake(self, block)\n   1308         self.settimeout(None)\n\
          -> 1309     self._sslobj.do_handshake()\n   1310 finally:\n\nConnectionResetError:\
          \ [Errno 104] Connection reset by peer\n\nDuring handling of the above exception,\
          \ another exception occurred:\n\nProtocolError                         \
          \    Traceback (most recent call last)\nFile /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:440,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n\
          \    439 if not chunked:\n--> 440     resp = conn.urlopen(\n    441    \
          \     method=request.method,\n    442         url=url,\n    443        \
          \ body=request.body,\n    444         headers=request.headers,\n    445\
          \         redirect=False,\n    446         assert_same_host=False,\n   \
          \ 447         preload_content=False,\n    448         decode_content=False,\n\
          \    449         retries=self.max_retries,\n    450         timeout=timeout\n\
          \    451     )\n    453 # Send the request.\n    454 else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:785,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    783     e = ProtocolError(\"Connection aborted.\"\
          , e)\n--> 785 retries = retries.increment(\n    786     method, url, error=e,\
          \ _pool=self, _stacktrace=sys.exc_info()[2]\n    787 )\n    788 retries.sleep()\n\
          \nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
          \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)\n\
          \    549 if read is False or not self._is_method_retryable(method):\n-->\
          \ 550     raise six.reraise(type(error), error, _stacktrace)\n    551 elif\
          \ read is not None:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
          \ in reraise(tp, value, tb)\n    768 if value.__traceback__ is not tb:\n\
          --> 769     raise value.with_traceback(tb)\n    770 raise value\n\nFile\
          \ /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    702 # Make the request on the httplib connection\
          \ object.\n--> 703 httplib_response = self._make_request(\n    704     conn,\n\
          \    705     method,\n    706     url,\n    707     timeout=timeout_obj,\n\
          \    708     body=body,\n    709     headers=headers,\n    710     chunked=chunked,\n\
          \    711 )\n    713 # If we're going to release the connection in ``finally:``,\
          \ then\n    714 # the response doesn't need to know about the connection.\
          \ Otherwise\n    715 # it will also try to release it and we'll have a double-release\n\
          \    716 # mess.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\n    385 try:\n--> 386     self._validate_conn(conn)\n\
          \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
          \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1039 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\n-> 1040     conn.connect()\n\
          \   1042 if not conn.is_verified:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
          --> 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416  \
          \   keyfile=self.key_file,\n    417     certfile=self.cert_file,\n    418\
          \     key_password=self.key_password,\n    419     ca_certs=self.ca_certs,\n\
          \    420     ca_cert_dir=self.ca_cert_dir,\n    421     ca_cert_data=self.ca_cert_data,\n\
          \    422     server_hostname=server_hostname,\n    423     ssl_context=context,\n\
          \    424     tls_in_tls=tls_in_tls,\n    425 )\n    427 # If we're using\
          \ all defaults and the connection\n    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning\n    429 # for the host.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\n    448 if send_sni:\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\n\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
          \    451     )\n    452 else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n\
          \    492 if server_hostname:\n--> 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\n    494 else:\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:500,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\n    494 def wrap_socket(self,\
          \ sock, server_side=False,\n    495                 do_handshake_on_connect=True,\n\
          \    496                 suppress_ragged_eofs=True,\n    497           \
          \      server_hostname=None, session=None):\n    498     # SSLSocket class\
          \ handles server_hostname encoding before it calls\n    499     # ctx._wrap_socket()\n\
          --> 500     return self.sslsocket_class._create(\n    501         sock=sock,\n\
          \    502         server_side=server_side,\n    503         do_handshake_on_connect=do_handshake_on_connect,\n\
          \    504         suppress_ragged_eofs=suppress_ragged_eofs,\n    505   \
          \      server_hostname=server_hostname,\n    506         context=self,\n\
          \    507         session=session\n    508     )\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1040,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\n   1039    \
          \         raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\n-> 1040         self.do_handshake()\n   1041\
          \ except (OSError, ValueError):\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1309,\
          \ in SSLSocket.do_handshake(self, block)\n   1308         self.settimeout(None)\n\
          -> 1309     self._sslobj.do_handshake()\n   1310 finally:\n\nProtocolError:\
          \ ('Connection aborted.', ConnectionResetError(104, 'Connection reset by\
          \ peer'))\n\nDuring handling of the above exception, another exception occurred:\n\
          \nConnectionError                           Traceback (most recent call\
          \ last)\nInput In [29], in <cell line: 5>()\n      1 # !pip install -U sentence-transformers\n\
          \      2 # from sentence_transformers import SentenceTransformer\n---->\
          \ 5 model = SentenceTransformer('moka-ai/m3e-base')\n\nFile /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
          \ in SentenceTransformer.__init__(self, model_name_or_path, modules, device,\
          \ cache_folder, use_auth_token)\n     83     model_path = os.path.join(cache_folder,\
          \ model_name_or_path.replace(\"/\", \"_\"))\n     85     if not os.path.exists(os.path.join(model_path,\
          \ 'modules.json')):\n     86         # Download from hub with caching\n\
          ---> 87         snapshot_download(model_name_or_path,\n     88         \
          \                    cache_dir=cache_folder,\n     89                  \
          \           library_name='sentence-transformers',\n     90             \
          \                library_version=__version__,\n     91                 \
          \            ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\n\
          \     92                             use_auth_token=use_auth_token)\n  \
          \   94 if os.path.exists(os.path.join(model_path, 'modules.json')):    #Load\
          \ as SentenceTransformer model\n     95     modules = self._load_sbert_model(model_path)\n\
          \nFile /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/util.py:491,\
          \ in snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
          \ user_agent, ignore_files, use_auth_token)\n    486 if version.parse(huggingface_hub.__version__)\
          \ >= version.parse(\"0.8.1\"):\n    487     # huggingface_hub v0.8.1 introduces\
          \ a new cache layout. We sill use a manual layout\n    488     # And need\
          \ to pass legacy_cache_layout=True to avoid that a warning will be printed\n\
          \    489     cached_download_args['legacy_cache_layout'] = True\n--> 491\
          \ path = cached_download(**cached_download_args)\n    493 if os.path.exists(path\
          \ + \".lock\"):\n    494     os.remove(path + \".lock\")\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:118,\
          \ in validate_hf_hub_args.<locals>._inner_fn(*args, **kwargs)\n    115 if\
          \ check_use_auth_token:\n    116     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.__name__,\
          \ has_token=has_token, kwargs=kwargs)\n--> 118 return fn(*args, **kwargs)\n\
          \nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:800,\
          \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
          \ force_download, force_filename, proxies, etag_timeout, resume_download,\
          \ token, local_files_only, legacy_cache_layout)\n    797 with temp_file_manager()\
          \ as temp_file:\n    798     logger.info(\"downloading %s to %s\", url,\
          \ temp_file.name)\n--> 800     http_get(\n    801         url_to_download,\n\
          \    802         temp_file,\n    803         proxies=proxies,\n    804 \
          \        resume_size=resume_size,\n    805         headers=headers,\n  \
          \  806         expected_size=expected_size,\n    807     )\n    809 logger.info(\"\
          storing %s in cache at %s\", url, cache_path)\n    810 _chmod_and_replace(temp_file.name,\
          \ cache_path)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
          \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries,\
          \ expected_size)\n    502 if resume_size > 0:\n    503     headers[\"Range\"\
          ] = \"bytes=%d-\" % (resume_size,)\n--> 505 r = _request_wrapper(\n    506\
          \     method=\"GET\",\n    507     url=url,\n    508     stream=True,\n\
          \    509     proxies=proxies,\n    510     headers=headers,\n    511   \
          \  timeout=timeout,\n    512     max_retries=max_retries,\n    513 )\n \
          \   514 hf_raise_for_status(r)\n    515 content_length = r.headers.get(\"\
          Content-Length\")\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
          \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
          \ timeout, follow_relative_redirects, **params)\n    439     return response\n\
          \    441 # 3. Exponential backoff\n--> 442 return http_backoff(\n    443\
          \     method=method,\n    444     url=url,\n    445     max_retries=max_retries,\n\
          \    446     base_wait_time=base_wait_time,\n    447     max_wait_time=max_wait_time,\n\
          \    448     retry_on_exceptions=(Timeout, ProxyError),\n    449     retry_on_status_codes=(),\n\
          \    450     timeout=timeout,\n    451     **params,\n    452 )\n\nFile\
          \ /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:258,\
          \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time,\
          \ retry_on_exceptions, retry_on_status_codes, **kwargs)\n    255     kwargs[\"\
          data\"].seek(io_obj_initial_pos)\n    257 # Perform request and return if\
          \ status_code is not in the retry list.\n--> 258 response = session.request(method=method,\
          \ url=url, **kwargs)\n    259 if response.status_code not in retry_on_status_codes:\n\
          \    260     return response\n\nFile /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:529,\
          \ in Session.request(self, method, url, params, data, headers, cookies,\
          \ files, auth, timeout, allow_redirects, proxies, hooks, stream, verify,\
          \ cert, json)\n    524 send_kwargs = {\n    525     'timeout': timeout,\n\
          \    526     'allow_redirects': allow_redirects,\n    527 }\n    528 send_kwargs.update(settings)\n\
          --> 529 resp = self.send(prep, **send_kwargs)\n    531 return resp\n\nFile\
          \ /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:645, in\
          \ Session.send(self, request, **kwargs)\n    642 start = preferred_clock()\n\
          \    644 # Send the request\n--> 645 r = adapter.send(request, **kwargs)\n\
          \    647 # Total elapsed time of the request (approximately)\n    648 elapsed\
          \ = preferred_clock() - start\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:63,\
          \ in UniqueRequestIdAdapter.send(self, request, *args, **kwargs)\n     61\
          \ \"\"\"Catch any RequestException to append request id to the error message\
          \ for debugging.\"\"\"\n     62 try:\n---> 63     return super().send(request,\
          \ *args, **kwargs)\n     64 except requests.RequestException as e:\n   \
          \  65     request_id = request.headers.get(X_AMZN_TRACE_ID)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:501,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n\
          \    498             raise\n    500 except (ProtocolError, socket.error)\
          \ as err:\n--> 501     raise ConnectionError(err, request=request)\n   \
          \ 503 except MaxRetryError as e:\n    504     if isinstance(e.reason, ConnectTimeoutError):\n\
          \    505         # TODO: Remove this in 3.0.0: see #2811\n\nConnectionError:\
          \ (ProtocolError('Connection aborted.', ConnectionResetError(104, 'Connection\
          \ reset by peer')), '(Request ID: ddd4ac08-2e62-424c-9563-9cb91e9d1379)')\n"
        updatedAt: '2023-08-22T08:27:40.100Z'
      numEdits: 1
      reactions: []
    id: 64e47077a236a0de4f6c0988
    type: comment
  author: justYeah
  content: "\u6A21\u578B\u5B9E\u4F8B\u5316\u65F6\uFF0C\u663E\u793A \u8BF7\u6C42\u8FDE\
    \u63A5\u5931\u8D25\uFF0C\u6709\u5927\u4F6C\u53EF\u4EE5\u5E2E\u5FD9\u770B\u4E0B\
    \u8FD9\u662F\u4E3A\u4EC0\u4E48\u5417\uFF1F\n\u5177\u4F53\u62A5\u9519\u5982\u4E0B\
    \uFF1A\nConnectionResetError                      Traceback (most recent call\
    \ last)\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
    \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\n\
    \    702 # Make the request on the httplib connection object.\n--> 703 httplib_response\
    \ = self._make_request(\n    704     conn,\n    705     method,\n    706     url,\n\
    \    707     timeout=timeout_obj,\n    708     body=body,\n    709     headers=headers,\n\
    \    710     chunked=chunked,\n    711 )\n    713 # If we're going to release\
    \ the connection in ``finally:``, then\n    714 # the response doesn't need to\
    \ know about the connection. Otherwise\n    715 # it will also try to release\
    \ it and we'll have a double-release\n    716 # mess.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
    \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout, chunked,\
    \ **httplib_request_kw)\n    385 try:\n--> 386     self._validate_conn(conn)\n\
    \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
    \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
    \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1039 if not getattr(conn,\
    \ \"sock\", None):  # AppEngine might not have  `.sock`\n-> 1040     conn.connect()\n\
    \   1042 if not conn.is_verified:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
    \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
    --> 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416     keyfile=self.key_file,\n\
    \    417     certfile=self.cert_file,\n    418     key_password=self.key_password,\n\
    \    419     ca_certs=self.ca_certs,\n    420     ca_cert_dir=self.ca_cert_dir,\n\
    \    421     ca_cert_data=self.ca_cert_data,\n    422     server_hostname=server_hostname,\n\
    \    423     ssl_context=context,\n    424     tls_in_tls=tls_in_tls,\n    425\
    \ )\n    427 # If we're using all defaults and the connection\n    428 # is TLSv1\
    \ or TLSv1.1 we throw a DeprecationWarning\n    429 # for the host.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
    \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
    \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
    \ tls_in_tls)\n    448 if send_sni:\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\n\
    \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
    \    451     )\n    452 else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
    \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n \
    \   492 if server_hostname:\n--> 493     return ssl_context.wrap_socket(sock,\
    \ server_hostname=server_hostname)\n    494 else:\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:500,\
    \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
    \ suppress_ragged_eofs, server_hostname, session)\n    494 def wrap_socket(self,\
    \ sock, server_side=False,\n    495                 do_handshake_on_connect=True,\n\
    \    496                 suppress_ragged_eofs=True,\n    497                 server_hostname=None,\
    \ session=None):\n    498     # SSLSocket class handles server_hostname encoding\
    \ before it calls\n    499     # ctx._wrap_socket()\n--> 500     return self.sslsocket_class._create(\n\
    \    501         sock=sock,\n    502         server_side=server_side,\n    503\
    \         do_handshake_on_connect=do_handshake_on_connect,\n    504         suppress_ragged_eofs=suppress_ragged_eofs,\n\
    \    505         server_hostname=server_hostname,\n    506         context=self,\n\
    \    507         session=session\n    508     )\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1040,\
    \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs,\
    \ server_hostname, context, session)\n   1039             raise ValueError(\"\
    do_handshake_on_connect should not be specified for non-blocking sockets\")\n\
    -> 1040         self.do_handshake()\n   1041 except (OSError, ValueError):\n\n\
    File /opt/anaconda3/lib/python3.9/ssl.py:1309, in SSLSocket.do_handshake(self,\
    \ block)\n   1308         self.settimeout(None)\n-> 1309     self._sslobj.do_handshake()\n\
    \   1310 finally:\n\nConnectionResetError: [Errno 104] Connection reset by peer\n\
    \nDuring handling of the above exception, another exception occurred:\n\nProtocolError\
    \                             Traceback (most recent call last)\nFile /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:440,\
    \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n\
    \    439 if not chunked:\n--> 440     resp = conn.urlopen(\n    441         method=request.method,\n\
    \    442         url=url,\n    443         body=request.body,\n    444       \
    \  headers=request.headers,\n    445         redirect=False,\n    446        \
    \ assert_same_host=False,\n    447         preload_content=False,\n    448   \
    \      decode_content=False,\n    449         retries=self.max_retries,\n    450\
    \         timeout=timeout\n    451     )\n    453 # Send the request.\n    454\
    \ else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:785,\
    \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\n\
    \    783     e = ProtocolError(\"Connection aborted.\", e)\n--> 785 retries =\
    \ retries.increment(\n    786     method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n\
    \    787 )\n    788 retries.sleep()\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
    \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)\n\
    \    549 if read is False or not self._is_method_retryable(method):\n--> 550 \
    \    raise six.reraise(type(error), error, _stacktrace)\n    551 elif read is\
    \ not None:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
    \ in reraise(tp, value, tb)\n    768 if value.__traceback__ is not tb:\n--> 769\
    \     raise value.with_traceback(tb)\n    770 raise value\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
    \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\n\
    \    702 # Make the request on the httplib connection object.\n--> 703 httplib_response\
    \ = self._make_request(\n    704     conn,\n    705     method,\n    706     url,\n\
    \    707     timeout=timeout_obj,\n    708     body=body,\n    709     headers=headers,\n\
    \    710     chunked=chunked,\n    711 )\n    713 # If we're going to release\
    \ the connection in ``finally:``, then\n    714 # the response doesn't need to\
    \ know about the connection. Otherwise\n    715 # it will also try to release\
    \ it and we'll have a double-release\n    716 # mess.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
    \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout, chunked,\
    \ **httplib_request_kw)\n    385 try:\n--> 386     self._validate_conn(conn)\n\
    \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
    \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connectionpool.py:1040,\
    \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1039 if not getattr(conn,\
    \ \"sock\", None):  # AppEngine might not have  `.sock`\n-> 1040     conn.connect()\n\
    \   1042 if not conn.is_verified:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/connection.py:414,\
    \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
    --> 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416     keyfile=self.key_file,\n\
    \    417     certfile=self.cert_file,\n    418     key_password=self.key_password,\n\
    \    419     ca_certs=self.ca_certs,\n    420     ca_cert_dir=self.ca_cert_dir,\n\
    \    421     ca_cert_data=self.ca_cert_data,\n    422     server_hostname=server_hostname,\n\
    \    423     ssl_context=context,\n    424     tls_in_tls=tls_in_tls,\n    425\
    \ )\n    427 # If we're using all defaults and the connection\n    428 # is TLSv1\
    \ or TLSv1.1 we throw a DeprecationWarning\n    429 # for the host.\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
    \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
    \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
    \ tls_in_tls)\n    448 if send_sni:\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\n\
    \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
    \    451     )\n    452 else:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
    \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n \
    \   492 if server_hostname:\n--> 493     return ssl_context.wrap_socket(sock,\
    \ server_hostname=server_hostname)\n    494 else:\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:500,\
    \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
    \ suppress_ragged_eofs, server_hostname, session)\n    494 def wrap_socket(self,\
    \ sock, server_side=False,\n    495                 do_handshake_on_connect=True,\n\
    \    496                 suppress_ragged_eofs=True,\n    497                 server_hostname=None,\
    \ session=None):\n    498     # SSLSocket class handles server_hostname encoding\
    \ before it calls\n    499     # ctx._wrap_socket()\n--> 500     return self.sslsocket_class._create(\n\
    \    501         sock=sock,\n    502         server_side=server_side,\n    503\
    \         do_handshake_on_connect=do_handshake_on_connect,\n    504         suppress_ragged_eofs=suppress_ragged_eofs,\n\
    \    505         server_hostname=server_hostname,\n    506         context=self,\n\
    \    507         session=session\n    508     )\n\nFile /opt/anaconda3/lib/python3.9/ssl.py:1040,\
    \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs,\
    \ server_hostname, context, session)\n   1039             raise ValueError(\"\
    do_handshake_on_connect should not be specified for non-blocking sockets\")\n\
    -> 1040         self.do_handshake()\n   1041 except (OSError, ValueError):\n\n\
    File /opt/anaconda3/lib/python3.9/ssl.py:1309, in SSLSocket.do_handshake(self,\
    \ block)\n   1308         self.settimeout(None)\n-> 1309     self._sslobj.do_handshake()\n\
    \   1310 finally:\n\nProtocolError: ('Connection aborted.', ConnectionResetError(104,\
    \ 'Connection reset by peer'))\n\nDuring handling of the above exception, another\
    \ exception occurred:\n\nConnectionError                           Traceback (most\
    \ recent call last)\nInput In [29], in <cell line: 5>()\n      1 # !pip install\
    \ -U sentence-transformers\n      2 # from sentence_transformers import SentenceTransformer\n\
    ----> 5 model = SentenceTransformer('moka-ai/m3e-base')\n\nFile /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
    \ in SentenceTransformer.__init__(self, model_name_or_path, modules, device, cache_folder,\
    \ use_auth_token)\n     83     model_path = os.path.join(cache_folder, model_name_or_path.replace(\"\
    /\", \"_\"))\n     85     if not os.path.exists(os.path.join(model_path, 'modules.json')):\n\
    \     86         # Download from hub with caching\n---> 87         snapshot_download(model_name_or_path,\n\
    \     88                             cache_dir=cache_folder,\n     89        \
    \                     library_name='sentence-transformers',\n     90         \
    \                    library_version=__version__,\n     91                   \
    \          ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\n\
    \     92                             use_auth_token=use_auth_token)\n     94 if\
    \ os.path.exists(os.path.join(model_path, 'modules.json')):    #Load as SentenceTransformer\
    \ model\n     95     modules = self._load_sbert_model(model_path)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/sentence_transformers/util.py:491,\
    \ in snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
    \ user_agent, ignore_files, use_auth_token)\n    486 if version.parse(huggingface_hub.__version__)\
    \ >= version.parse(\"0.8.1\"):\n    487     # huggingface_hub v0.8.1 introduces\
    \ a new cache layout. We sill use a manual layout\n    488     # And need to pass\
    \ legacy_cache_layout=True to avoid that a warning will be printed\n    489  \
    \   cached_download_args['legacy_cache_layout'] = True\n--> 491 path = cached_download(**cached_download_args)\n\
    \    493 if os.path.exists(path + \".lock\"):\n    494     os.remove(path + \"\
    .lock\")\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:118,\
    \ in validate_hf_hub_args.<locals>._inner_fn(*args, **kwargs)\n    115 if check_use_auth_token:\n\
    \    116     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.__name__, has_token=has_token,\
    \ kwargs=kwargs)\n--> 118 return fn(*args, **kwargs)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:800,\
    \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
    \ force_download, force_filename, proxies, etag_timeout, resume_download, token,\
    \ local_files_only, legacy_cache_layout)\n    797 with temp_file_manager() as\
    \ temp_file:\n    798     logger.info(\"downloading %s to %s\", url, temp_file.name)\n\
    --> 800     http_get(\n    801         url_to_download,\n    802         temp_file,\n\
    \    803         proxies=proxies,\n    804         resume_size=resume_size,\n\
    \    805         headers=headers,\n    806         expected_size=expected_size,\n\
    \    807     )\n    809 logger.info(\"storing %s in cache at %s\", url, cache_path)\n\
    \    810 _chmod_and_replace(temp_file.name, cache_path)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
    \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries,\
    \ expected_size)\n    502 if resume_size > 0:\n    503     headers[\"Range\"]\
    \ = \"bytes=%d-\" % (resume_size,)\n--> 505 r = _request_wrapper(\n    506   \
    \  method=\"GET\",\n    507     url=url,\n    508     stream=True,\n    509  \
    \   proxies=proxies,\n    510     headers=headers,\n    511     timeout=timeout,\n\
    \    512     max_retries=max_retries,\n    513 )\n    514 hf_raise_for_status(r)\n\
    \    515 content_length = r.headers.get(\"Content-Length\")\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
    \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
    \ timeout, follow_relative_redirects, **params)\n    439     return response\n\
    \    441 # 3. Exponential backoff\n--> 442 return http_backoff(\n    443     method=method,\n\
    \    444     url=url,\n    445     max_retries=max_retries,\n    446     base_wait_time=base_wait_time,\n\
    \    447     max_wait_time=max_wait_time,\n    448     retry_on_exceptions=(Timeout,\
    \ ProxyError),\n    449     retry_on_status_codes=(),\n    450     timeout=timeout,\n\
    \    451     **params,\n    452 )\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:258,\
    \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time, retry_on_exceptions,\
    \ retry_on_status_codes, **kwargs)\n    255     kwargs[\"data\"].seek(io_obj_initial_pos)\n\
    \    257 # Perform request and return if status_code is not in the retry list.\n\
    --> 258 response = session.request(method=method, url=url, **kwargs)\n    259\
    \ if response.status_code not in retry_on_status_codes:\n    260     return response\n\
    \nFile /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:529, in\
    \ Session.request(self, method, url, params, data, headers, cookies, files, auth,\
    \ timeout, allow_redirects, proxies, hooks, stream, verify, cert, json)\n    524\
    \ send_kwargs = {\n    525     'timeout': timeout,\n    526     'allow_redirects':\
    \ allow_redirects,\n    527 }\n    528 send_kwargs.update(settings)\n--> 529 resp\
    \ = self.send(prep, **send_kwargs)\n    531 return resp\n\nFile /opt/anaconda3/lib/python3.9/site-packages/requests/sessions.py:645,\
    \ in Session.send(self, request, **kwargs)\n    642 start = preferred_clock()\n\
    \    644 # Send the request\n--> 645 r = adapter.send(request, **kwargs)\n   \
    \ 647 # Total elapsed time of the request (approximately)\n    648 elapsed = preferred_clock()\
    \ - start\n\nFile /opt/anaconda3/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:63,\
    \ in UniqueRequestIdAdapter.send(self, request, *args, **kwargs)\n     61 \"\"\
    \"Catch any RequestException to append request id to the error message for debugging.\"\
    \"\"\n     62 try:\n---> 63     return super().send(request, *args, **kwargs)\n\
    \     64 except requests.RequestException as e:\n     65     request_id = request.headers.get(X_AMZN_TRACE_ID)\n\
    \nFile /opt/anaconda3/lib/python3.9/site-packages/requests/adapters.py:501, in\
    \ HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n  \
    \  498             raise\n    500 except (ProtocolError, socket.error) as err:\n\
    --> 501     raise ConnectionError(err, request=request)\n    503 except MaxRetryError\
    \ as e:\n    504     if isinstance(e.reason, ConnectTimeoutError):\n    505  \
    \       # TODO: Remove this in 3.0.0: see #2811\n\nConnectionError: (ProtocolError('Connection\
    \ aborted.', ConnectionResetError(104, 'Connection reset by peer')), '(Request\
    \ ID: ddd4ac08-2e62-424c-9563-9cb91e9d1379)')\n"
  created_at: 2023-08-22 07:23:19+00:00
  edited: true
  hidden: false
  id: 64e47077a236a0de4f6c0988
  type: comment
- !!python/object:huggingface_hub.community.DiscussionStatusChange
  _event:
    author:
      avatarUrl: /avatars/f903c9712a01d711d8b2c78fb0631042.svg
      fullname: changjuhao
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: justYeah
      type: user
    createdAt: '2023-08-22T08:23:36.000Z'
    data:
      status: closed
    id: 64e470881887a952de8fe74c
    type: status-change
  author: justYeah
  created_at: 2023-08-22 07:23:36+00:00
  id: 64e470881887a952de8fe74c
  new_status: closed
  type: status-change
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/noauth/NbjjEhhwMdzDz-jdOrwdu.png?w=200&h=200&f=face
      fullname: Moka HR SaSS
      isHf: false
      isOrgMember: true
      isOwner: false
      isPro: false
      name: MokaHR
      type: user
    createdAt: '2023-10-10T02:40:48.000Z'
    data:
      edited: false
      editors:
      - MokaHR
      hidden: false
      identifiedLanguage:
        language: zh
        probability: 1.0000137090682983
      isReport: false
      latest:
        author:
          avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/noauth/NbjjEhhwMdzDz-jdOrwdu.png?w=200&h=200&f=face
          fullname: Moka HR SaSS
          isHf: false
          isPro: false
          name: MokaHR
          type: user
        html: "<p>\u7F51\u7EDC\u7684\u539F\u56E0\u5BFC\u81F4\u7684</p>\n"
        raw: "\u7F51\u7EDC\u7684\u539F\u56E0\u5BFC\u81F4\u7684"
        updatedAt: '2023-10-10T02:40:48.685Z'
      numEdits: 0
      reactions: []
    id: 6524b9b021af4b073087cf28
    type: comment
  author: MokaHR
  content: "\u7F51\u7EDC\u7684\u539F\u56E0\u5BFC\u81F4\u7684"
  created_at: 2023-10-10 01:40:48+00:00
  edited: false
  hidden: false
  id: 6524b9b021af4b073087cf28
  type: comment
is_pull_request: false
merge_commit_oid: null
num: 24
repo_id: moka-ai/m3e-base
repo_type: model
status: closed
target_branch: null
title: "\u5B9E\u4F8B\u5316 model = SentenceTransformer('moka-ai/m3e-base') \u65F6\uFF0C\
  \u4E3A\u4EC0\u4E48\u663E\u793A ConnectionError\u5462\uFF1F"
