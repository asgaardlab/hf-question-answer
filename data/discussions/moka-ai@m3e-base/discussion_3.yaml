!!python/object:huggingface_hub.community.DiscussionWithDetails
author: sunchao1212
conflicting_files: null
created_at: 2023-06-14 02:47:43+00:00
diff: null
endpoint: https://huggingface.co
events:
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: /avatars/9635043e366ff2f77b1379a42f790279.svg
      fullname: sunchao
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: sunchao1212
      type: user
    createdAt: '2023-06-14T03:47:43.000Z'
    data:
      edited: false
      editors:
      - sunchao1212
      hidden: false
      identifiedLanguage:
        language: en
        probability: 0.40017157793045044
      isReport: false
      latest:
        author:
          avatarUrl: /avatars/9635043e366ff2f77b1379a42f790279.svg
          fullname: sunchao
          isHf: false
          isPro: false
          name: sunchao1212
          type: user
        html: "<p>When running my code this error appears.<br>Code:</p>\n<pre><code>from\
          \ sentence_transformers import SentenceTransformer\nmodel = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\n\
          </code></pre>\n<p>Traceback:</p>\n<pre><code>---------------------------------------------------------------------------\n\
          ConnectionResetError                      Traceback (most recent call last)\n\
          File /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    702 # Make the request on the httplib connection\
          \ object.\n--&gt; 703 httplib_response = self._make_request(\n    704  \
          \   conn,\n    705     method,\n    706     url,\n    707     timeout=timeout_obj,\n\
          \    708     body=body,\n    709     headers=headers,\n    710     chunked=chunked,\n\
          \    711 )\n    713 # If we're going to release the connection in ``finally:``,\
          \ then\n    714 # the response doesn't need to know about the connection.\
          \ Otherwise\n    715 # it will also try to release it and we'll have a double-release\n\
          \    716 # mess.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\n    385 try:\n--&gt; 386     self._validate_conn(conn)\n\
          \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
          \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1041 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\n-&gt; 1042    \
          \ conn.connect()\n   1044 if not conn.is_verified:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
          --&gt; 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416\
          \     keyfile=self.key_file,\n    417     certfile=self.cert_file,\n   \
          \ 418     key_password=self.key_password,\n    419     ca_certs=self.ca_certs,\n\
          \    420     ca_cert_dir=self.ca_cert_dir,\n    421     ca_cert_data=self.ca_cert_data,\n\
          \    422     server_hostname=server_hostname,\n    423     ssl_context=context,\n\
          \    424     tls_in_tls=tls_in_tls,\n    425 )\n    427 # If we're using\
          \ all defaults and the connection\n    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning\n    429 # for the host.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\n    448 if send_sni:\n--&gt; 449     ssl_sock = _ssl_wrap_socket_impl(\n\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
          \    451     )\n    452 else:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n\
          \    492 if server_hostname:\n--&gt; 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\n    494 else:\n\nFile /home/pai/lib/python3.9/ssl.py:501,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\n    495 def wrap_socket(self,\
          \ sock, server_side=False,\n    496                 do_handshake_on_connect=True,\n\
          \    497                 suppress_ragged_eofs=True,\n    498           \
          \      server_hostname=None, session=None):\n    499     # SSLSocket class\
          \ handles server_hostname encoding before it calls\n    500     # ctx._wrap_socket()\n\
          --&gt; 501     return self.sslsocket_class._create(\n    502         sock=sock,\n\
          \    503         server_side=server_side,\n    504         do_handshake_on_connect=do_handshake_on_connect,\n\
          \    505         suppress_ragged_eofs=suppress_ragged_eofs,\n    506   \
          \      server_hostname=server_hostname,\n    507         context=self,\n\
          \    508         session=session\n    509     )\n\nFile /home/pai/lib/python3.9/ssl.py:1041,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\n   1040    \
          \         raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\n-&gt; 1041         self.do_handshake()\n\
          \   1042 except (OSError, ValueError):\n\nFile /home/pai/lib/python3.9/ssl.py:1310,\
          \ in SSLSocket.do_handshake(self, block)\n   1309         self.settimeout(None)\n\
          -&gt; 1310     self._sslobj.do_handshake()\n   1311 finally:\n\nConnectionResetError:\
          \ [Errno 104] Connection reset by peer\n\nDuring handling of the above exception,\
          \ another exception occurred:\n\nProtocolError                         \
          \    Traceback (most recent call last)\nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:489,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n\
          \    488 if not chunked:\n--&gt; 489     resp = conn.urlopen(\n    490 \
          \        method=request.method,\n    491         url=url,\n    492     \
          \    body=request.body,\n    493         headers=request.headers,\n    494\
          \         redirect=False,\n    495         assert_same_host=False,\n   \
          \ 496         preload_content=False,\n    497         decode_content=False,\n\
          \    498         retries=self.max_retries,\n    499         timeout=timeout,\n\
          \    500     )\n    502 # Send the request.\n    503 else:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:787,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    785     e = ProtocolError(\"Connection aborted.\"\
          , e)\n--&gt; 787 retries = retries.increment(\n    788     method, url,\
          \ error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n    789 )\n    790\
          \ retries.sleep()\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
          \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)\n\
          \    549 if read is False or not self._is_method_retryable(method):\n--&gt;\
          \ 550     raise six.reraise(type(error), error, _stacktrace)\n    551 elif\
          \ read is not None:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
          \ in reraise(tp, value, tb)\n    768 if value.__traceback__ is not tb:\n\
          --&gt; 769     raise value.with_traceback(tb)\n    770 raise value\n\nFile\
          \ /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703, in\
          \ HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\n    702 # Make the request on the httplib connection\
          \ object.\n--&gt; 703 httplib_response = self._make_request(\n    704  \
          \   conn,\n    705     method,\n    706     url,\n    707     timeout=timeout_obj,\n\
          \    708     body=body,\n    709     headers=headers,\n    710     chunked=chunked,\n\
          \    711 )\n    713 # If we're going to release the connection in ``finally:``,\
          \ then\n    714 # the response doesn't need to know about the connection.\
          \ Otherwise\n    715 # it will also try to release it and we'll have a double-release\n\
          \    716 # mess.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\n    385 try:\n--&gt; 386     self._validate_conn(conn)\n\
          \    387 except (SocketTimeout, BaseSSLError) as e:\n    388     # Py2 raises\
          \ this as a BaseSSLError, Py3 raises it as socket timeout.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\n   1041 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\n-&gt; 1042    \
          \ conn.connect()\n   1044 if not conn.is_verified:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\n    412     context.load_default_certs()\n\
          --&gt; 414 self.sock = ssl_wrap_socket(\n    415     sock=conn,\n    416\
          \     keyfile=self.key_file,\n    417     certfile=self.cert_file,\n   \
          \ 418     key_password=self.key_password,\n    419     ca_certs=self.ca_certs,\n\
          \    420     ca_cert_dir=self.ca_cert_dir,\n    421     ca_cert_data=self.ca_cert_data,\n\
          \    422     server_hostname=server_hostname,\n    423     ssl_context=context,\n\
          \    424     tls_in_tls=tls_in_tls,\n    425 )\n    427 # If we're using\
          \ all defaults and the connection\n    428 # is TLSv1 or TLSv1.1 we throw\
          \ a DeprecationWarning\n    429 # for the host.\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\n    448 if send_sni:\n--&gt; 449     ssl_sock = _ssl_wrap_socket_impl(\n\
          \    450         sock, context, tls_in_tls, server_hostname=server_hostname\n\
          \    451     )\n    452 else:\n\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\n\
          \    492 if server_hostname:\n--&gt; 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\n    494 else:\n\nFile /home/pai/lib/python3.9/ssl.py:501,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\n    495 def wrap_socket(self,\
          \ sock, server_side=False,\n    496                 do_handshake_on_connect=True,\n\
          \    497                 suppress_ragged_eofs=True,\n    498           \
          \      server_hostname=None, session=None):\n    499     # SSLSocket class\
          \ handles server_hostname encoding before it calls\n    500     # ctx._wrap_socket()\n\
          --&gt; 501     return self.sslsocket_class._create(\n    502         sock=sock,\n\
          \    503         server_side=server_side,\n    504         do_handshake_on_connect=do_handshake_on_connect,\n\
          \    505         suppress_ragged_eofs=suppress_ragged_eofs,\n    506   \
          \      server_hostname=server_hostname,\n    507         context=self,\n\
          \    508         session=session\n    509     )\n\nFile /home/pai/lib/python3.9/ssl.py:1041,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\n   1040    \
          \         raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\n-&gt; 1041         self.do_handshake()\n\
          \   1042 except (OSError, ValueError):\n\nFile /home/pai/lib/python3.9/ssl.py:1310,\
          \ in SSLSocket.do_handshake(self, block)\n   1309         self.settimeout(None)\n\
          -&gt; 1310     self._sslobj.do_handshake()\n   1311 finally:\n\nProtocolError:\
          \ ('Connection aborted.', ConnectionResetError(104, 'Connection reset by\
          \ peer'))\n\nDuring handling of the above exception, another exception occurred:\n\
          \nConnectionError                           Traceback (most recent call\
          \ last)\nCell In[3], line 2\n      1 from sentence_transformers import SentenceTransformer\n\
          ----&gt; 2 model = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\n\
          \nFile /home/pai/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
          \ in SentenceTransformer.__init__(self, model_name_or_path, modules, device,\
          \ cache_folder, use_auth_token)\n     83     model_path = os.path.join(cache_folder,\
          \ model_name_or_path.replace(\"/\", \"_\"))\n     85     if not os.path.exists(os.path.join(model_path,\
          \ 'modules.json')):\n     86         # Download from hub with caching\n\
          ---&gt; 87         snapshot_download(model_name_or_path,\n     88      \
          \                       cache_dir=cache_folder,\n     89               \
          \              library_name='sentence-transformers',\n     90          \
          \                   library_version=__version__,\n     91              \
          \               ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\n\
          \     92                             use_auth_token=use_auth_token)\n  \
          \   94 if os.path.exists(os.path.join(model_path, 'modules.json')):    #Load\
          \ as SentenceTransformer model\n     95     modules = self._load_sbert_model(model_path)\n\
          \nFile /home/pai/lib/python3.9/site-packages/sentence_transformers/util.py:491,\
          \ in snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
          \ user_agent, ignore_files, use_auth_token)\n    486 if version.parse(huggingface_hub.__version__)\
          \ &gt;= version.parse(\"0.8.1\"):\n    487     # huggingface_hub v0.8.1\
          \ introduces a new cache layout. We sill use a manual layout\n    488  \
          \   # And need to pass legacy_cache_layout=True to avoid that a warning\
          \ will be printed\n    489     cached_download_args['legacy_cache_layout']\
          \ = True\n--&gt; 491 path = cached_download(**cached_download_args)\n  \
          \  493 if os.path.exists(path + \".lock\"):\n    494     os.remove(path\
          \ + \".lock\")\n\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:120,\
          \ in validate_hf_hub_args.&lt;locals&gt;._inner_fn(*args, **kwargs)\n  \
          \  117 if check_use_auth_token:\n    118     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.__name__,\
          \ has_token=has_token, kwargs=kwargs)\n--&gt; 120 return fn(*args, **kwargs)\n\
          \nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:780,\
          \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
          \ force_download, force_filename, proxies, etag_timeout, resume_download,\
          \ token, local_files_only, legacy_cache_layout)\n    777 with temp_file_manager()\
          \ as temp_file:\n    778     logger.info(\"downloading %s to %s\", url,\
          \ temp_file.name)\n--&gt; 780     http_get(\n    781         url_to_download,\n\
          \    782         temp_file,\n    783         proxies=proxies,\n    784 \
          \        resume_size=resume_size,\n    785         headers=headers,\n  \
          \  786     )\n    788 logger.info(\"storing %s in cache at %s\", url, cache_path)\n\
          \    789 _chmod_and_replace(temp_file.name, cache_path)\n\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
          \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries)\n\
          \    502 if resume_size &gt; 0:\n    503     headers[\"Range\"] = \"bytes=%d-\"\
          \ % (resume_size,)\n--&gt; 505 r = _request_wrapper(\n    506     method=\"\
          GET\",\n    507     url=url,\n    508     stream=True,\n    509     proxies=proxies,\n\
          \    510     headers=headers,\n    511     timeout=timeout,\n    512   \
          \  max_retries=max_retries,\n    513 )\n    514 hf_raise_for_status(r)\n\
          \    515 content_length = r.headers.get(\"Content-Length\")\n\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
          \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
          \ timeout, follow_relative_redirects, **params)\n    439     return response\n\
          \    441 # 3. Exponential backoff\n--&gt; 442 return http_backoff(\n   \
          \ 443     method=method,\n    444     url=url,\n    445     max_retries=max_retries,\n\
          \    446     base_wait_time=base_wait_time,\n    447     max_wait_time=max_wait_time,\n\
          \    448     retry_on_exceptions=(ConnectTimeout, ProxyError),\n    449\
          \     retry_on_status_codes=(),\n    450     timeout=timeout,\n    451 \
          \    **params,\n    452 )\n\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:129,\
          \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time,\
          \ retry_on_exceptions, retry_on_status_codes, **kwargs)\n    126     kwargs[\"\
          data\"].seek(io_obj_initial_pos)\n    128 # Perform request and return if\
          \ status_code is not in the retry list.\n--&gt; 129 response = requests.request(method=method,\
          \ url=url, **kwargs)\n    130 if response.status_code not in retry_on_status_codes:\n\
          \    131     return response\n\nFile /home/pai/lib/python3.9/site-packages/requests/api.py:59,\
          \ in request(method, url, **kwargs)\n     55 # By using the 'with' statement\
          \ we are sure the session is closed, thus we\n     56 # avoid leaving sockets\
          \ open which can trigger a ResourceWarning in some\n     57 # cases, and\
          \ look like a memory leak in others.\n     58 with sessions.Session() as\
          \ session:\n---&gt; 59     return session.request(method=method, url=url,\
          \ **kwargs)\n\nFile /home/pai/lib/python3.9/site-packages/requests/sessions.py:587,\
          \ in Session.request(self, method, url, params, data, headers, cookies,\
          \ files, auth, timeout, allow_redirects, proxies, hooks, stream, verify,\
          \ cert, json)\n    582 send_kwargs = {\n    583     \"timeout\": timeout,\n\
          \    584     \"allow_redirects\": allow_redirects,\n    585 }\n    586 send_kwargs.update(settings)\n\
          --&gt; 587 resp = self.send(prep, **send_kwargs)\n    589 return resp\n\n\
          File /home/pai/lib/python3.9/site-packages/requests/sessions.py:701, in\
          \ Session.send(self, request, **kwargs)\n    698 start = preferred_clock()\n\
          \    700 # Send the request\n--&gt; 701 r = adapter.send(request, **kwargs)\n\
          \    703 # Total elapsed time of the request (approximately)\n    704 elapsed\
          \ = preferred_clock() - start\n\nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:547,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\n\
          \    544             raise\n    546 except (ProtocolError, OSError) as err:\n\
          --&gt; 547     raise ConnectionError(err, request=request)\n    549 except\
          \ MaxRetryError as e:\n    550     if isinstance(e.reason, ConnectTimeoutError):\n\
          \    551         # TODO: Remove this in 3.0.0: see #2811\n\nConnectionError:\
          \ ('Connection aborted.', ConnectionResetError(104, 'Connection reset by\
          \ peer'))\n</code></pre>\n"
        raw: "When running my code this error appears.\r\nCode:\r\n```\r\nfrom sentence_transformers\
          \ import SentenceTransformer\r\nmodel = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\r\
          \n```\r\n\r\nTraceback:\r\n```\r\n---------------------------------------------------------------------------\r\
          \nConnectionResetError                      Traceback (most recent call\
          \ last)\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\r\n    702 # Make the request on the httplib\
          \ connection object.\r\n--> 703 httplib_response = self._make_request(\r\
          \n    704     conn,\r\n    705     method,\r\n    706     url,\r\n    707\
          \     timeout=timeout_obj,\r\n    708     body=body,\r\n    709     headers=headers,\r\
          \n    710     chunked=chunked,\r\n    711 )\r\n    713 # If we're going\
          \ to release the connection in ``finally:``, then\r\n    714 # the response\
          \ doesn't need to know about the connection. Otherwise\r\n    715 # it will\
          \ also try to release it and we'll have a double-release\r\n    716 # mess.\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\r\n    385 try:\r\n--> 386     self._validate_conn(conn)\r\
          \n    387 except (SocketTimeout, BaseSSLError) as e:\r\n    388     # Py2\
          \ raises this as a BaseSSLError, Py3 raises it as socket timeout.\r\n\r\n\
          File /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\r\n   1041 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\r\n-> 1042     conn.connect()\r\
          \n   1044 if not conn.is_verified:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\r\n    412     context.load_default_certs()\r\
          \n--> 414 self.sock = ssl_wrap_socket(\r\n    415     sock=conn,\r\n   \
          \ 416     keyfile=self.key_file,\r\n    417     certfile=self.cert_file,\r\
          \n    418     key_password=self.key_password,\r\n    419     ca_certs=self.ca_certs,\r\
          \n    420     ca_cert_dir=self.ca_cert_dir,\r\n    421     ca_cert_data=self.ca_cert_data,\r\
          \n    422     server_hostname=server_hostname,\r\n    423     ssl_context=context,\r\
          \n    424     tls_in_tls=tls_in_tls,\r\n    425 )\r\n    427 # If we're\
          \ using all defaults and the connection\r\n    428 # is TLSv1 or TLSv1.1\
          \ we throw a DeprecationWarning\r\n    429 # for the host.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\r\n    448 if send_sni:\r\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\r\
          \n    450         sock, context, tls_in_tls, server_hostname=server_hostname\r\
          \n    451     )\r\n    452 else:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\r\
          \n    492 if server_hostname:\r\n--> 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\r\n    494 else:\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:501,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\r\n    495 def wrap_socket(self,\
          \ sock, server_side=False,\r\n    496                 do_handshake_on_connect=True,\r\
          \n    497                 suppress_ragged_eofs=True,\r\n    498        \
          \         server_hostname=None, session=None):\r\n    499     # SSLSocket\
          \ class handles server_hostname encoding before it calls\r\n    500    \
          \ # ctx._wrap_socket()\r\n--> 501     return self.sslsocket_class._create(\r\
          \n    502         sock=sock,\r\n    503         server_side=server_side,\r\
          \n    504         do_handshake_on_connect=do_handshake_on_connect,\r\n \
          \   505         suppress_ragged_eofs=suppress_ragged_eofs,\r\n    506  \
          \       server_hostname=server_hostname,\r\n    507         context=self,\r\
          \n    508         session=session\r\n    509     )\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1041,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\r\n   1040  \
          \           raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\r\n-> 1041         self.do_handshake()\r\n\
          \   1042 except (OSError, ValueError):\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1310,\
          \ in SSLSocket.do_handshake(self, block)\r\n   1309         self.settimeout(None)\r\
          \n-> 1310     self._sslobj.do_handshake()\r\n   1311 finally:\r\n\r\nConnectionResetError:\
          \ [Errno 104] Connection reset by peer\r\n\r\nDuring handling of the above\
          \ exception, another exception occurred:\r\n\r\nProtocolError          \
          \                   Traceback (most recent call last)\r\nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:489,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\r\
          \n    488 if not chunked:\r\n--> 489     resp = conn.urlopen(\r\n    490\
          \         method=request.method,\r\n    491         url=url,\r\n    492\
          \         body=request.body,\r\n    493         headers=request.headers,\r\
          \n    494         redirect=False,\r\n    495         assert_same_host=False,\r\
          \n    496         preload_content=False,\r\n    497         decode_content=False,\r\
          \n    498         retries=self.max_retries,\r\n    499         timeout=timeout,\r\
          \n    500     )\r\n    502 # Send the request.\r\n    503 else:\r\n\r\n\
          File /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:787,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\r\n    785     e = ProtocolError(\"Connection\
          \ aborted.\", e)\r\n--> 787 retries = retries.increment(\r\n    788    \
          \ method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\r\n  \
          \  789 )\r\n    790 retries.sleep()\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
          \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)\r\
          \n    549 if read is False or not self._is_method_retryable(method):\r\n\
          --> 550     raise six.reraise(type(error), error, _stacktrace)\r\n    551\
          \ elif read is not None:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
          \ in reraise(tp, value, tb)\r\n    768 if value.__traceback__ is not tb:\r\
          \n--> 769     raise value.with_traceback(tb)\r\n    770 raise value\r\n\r\
          \nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
          \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries,\
          \ redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked,\
          \ body_pos, **response_kw)\r\n    702 # Make the request on the httplib\
          \ connection object.\r\n--> 703 httplib_response = self._make_request(\r\
          \n    704     conn,\r\n    705     method,\r\n    706     url,\r\n    707\
          \     timeout=timeout_obj,\r\n    708     body=body,\r\n    709     headers=headers,\r\
          \n    710     chunked=chunked,\r\n    711 )\r\n    713 # If we're going\
          \ to release the connection in ``finally:``, then\r\n    714 # the response\
          \ doesn't need to know about the connection. Otherwise\r\n    715 # it will\
          \ also try to release it and we'll have a double-release\r\n    716 # mess.\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
          \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout,\
          \ chunked, **httplib_request_kw)\r\n    385 try:\r\n--> 386     self._validate_conn(conn)\r\
          \n    387 except (SocketTimeout, BaseSSLError) as e:\r\n    388     # Py2\
          \ raises this as a BaseSSLError, Py3 raises it as socket timeout.\r\n\r\n\
          File /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
          \ in HTTPSConnectionPool._validate_conn(self, conn)\r\n   1041 if not getattr(conn,\
          \ \"sock\", None):  # AppEngine might not have  `.sock`\r\n-> 1042     conn.connect()\r\
          \n   1044 if not conn.is_verified:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
          \ in HTTPSConnection.connect(self)\r\n    412     context.load_default_certs()\r\
          \n--> 414 self.sock = ssl_wrap_socket(\r\n    415     sock=conn,\r\n   \
          \ 416     keyfile=self.key_file,\r\n    417     certfile=self.cert_file,\r\
          \n    418     key_password=self.key_password,\r\n    419     ca_certs=self.ca_certs,\r\
          \n    420     ca_cert_dir=self.ca_cert_dir,\r\n    421     ca_cert_data=self.ca_cert_data,\r\
          \n    422     server_hostname=server_hostname,\r\n    423     ssl_context=context,\r\
          \n    424     tls_in_tls=tls_in_tls,\r\n    425 )\r\n    427 # If we're\
          \ using all defaults and the connection\r\n    428 # is TLSv1 or TLSv1.1\
          \ we throw a DeprecationWarning\r\n    429 # for the host.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
          \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
          \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
          \ tls_in_tls)\r\n    448 if send_sni:\r\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\r\
          \n    450         sock, context, tls_in_tls, server_hostname=server_hostname\r\
          \n    451     )\r\n    452 else:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
          \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\r\
          \n    492 if server_hostname:\r\n--> 493     return ssl_context.wrap_socket(sock,\
          \ server_hostname=server_hostname)\r\n    494 else:\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:501,\
          \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, session)\r\n    495 def wrap_socket(self,\
          \ sock, server_side=False,\r\n    496                 do_handshake_on_connect=True,\r\
          \n    497                 suppress_ragged_eofs=True,\r\n    498        \
          \         server_hostname=None, session=None):\r\n    499     # SSLSocket\
          \ class handles server_hostname encoding before it calls\r\n    500    \
          \ # ctx._wrap_socket()\r\n--> 501     return self.sslsocket_class._create(\r\
          \n    502         sock=sock,\r\n    503         server_side=server_side,\r\
          \n    504         do_handshake_on_connect=do_handshake_on_connect,\r\n \
          \   505         suppress_ragged_eofs=suppress_ragged_eofs,\r\n    506  \
          \       server_hostname=server_hostname,\r\n    507         context=self,\r\
          \n    508         session=session\r\n    509     )\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1041,\
          \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect,\
          \ suppress_ragged_eofs, server_hostname, context, session)\r\n   1040  \
          \           raise ValueError(\"do_handshake_on_connect should not be specified\
          \ for non-blocking sockets\")\r\n-> 1041         self.do_handshake()\r\n\
          \   1042 except (OSError, ValueError):\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1310,\
          \ in SSLSocket.do_handshake(self, block)\r\n   1309         self.settimeout(None)\r\
          \n-> 1310     self._sslobj.do_handshake()\r\n   1311 finally:\r\n\r\nProtocolError:\
          \ ('Connection aborted.', ConnectionResetError(104, 'Connection reset by\
          \ peer'))\r\n\r\nDuring handling of the above exception, another exception\
          \ occurred:\r\n\r\nConnectionError                           Traceback (most\
          \ recent call last)\r\nCell In[3], line 2\r\n      1 from sentence_transformers\
          \ import SentenceTransformer\r\n----> 2 model = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
          \ in SentenceTransformer.__init__(self, model_name_or_path, modules, device,\
          \ cache_folder, use_auth_token)\r\n     83     model_path = os.path.join(cache_folder,\
          \ model_name_or_path.replace(\"/\", \"_\"))\r\n     85     if not os.path.exists(os.path.join(model_path,\
          \ 'modules.json')):\r\n     86         # Download from hub with caching\r\
          \n---> 87         snapshot_download(model_name_or_path,\r\n     88     \
          \                        cache_dir=cache_folder,\r\n     89            \
          \                 library_name='sentence-transformers',\r\n     90     \
          \                        library_version=__version__,\r\n     91       \
          \                      ignore_files=['flax_model.msgpack', 'rust_model.ot',\
          \ 'tf_model.h5'],\r\n     92                             use_auth_token=use_auth_token)\r\
          \n     94 if os.path.exists(os.path.join(model_path, 'modules.json')): \
          \   #Load as SentenceTransformer model\r\n     95     modules = self._load_sbert_model(model_path)\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/sentence_transformers/util.py:491,\
          \ in snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
          \ user_agent, ignore_files, use_auth_token)\r\n    486 if version.parse(huggingface_hub.__version__)\
          \ >= version.parse(\"0.8.1\"):\r\n    487     # huggingface_hub v0.8.1 introduces\
          \ a new cache layout. We sill use a manual layout\r\n    488     # And need\
          \ to pass legacy_cache_layout=True to avoid that a warning will be printed\r\
          \n    489     cached_download_args['legacy_cache_layout'] = True\r\n-->\
          \ 491 path = cached_download(**cached_download_args)\r\n    493 if os.path.exists(path\
          \ + \".lock\"):\r\n    494     os.remove(path + \".lock\")\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:120,\
          \ in validate_hf_hub_args.<locals>._inner_fn(*args, **kwargs)\r\n    117\
          \ if check_use_auth_token:\r\n    118     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.__name__,\
          \ has_token=has_token, kwargs=kwargs)\r\n--> 120 return fn(*args, **kwargs)\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:780,\
          \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
          \ force_download, force_filename, proxies, etag_timeout, resume_download,\
          \ token, local_files_only, legacy_cache_layout)\r\n    777 with temp_file_manager()\
          \ as temp_file:\r\n    778     logger.info(\"downloading %s to %s\", url,\
          \ temp_file.name)\r\n--> 780     http_get(\r\n    781         url_to_download,\r\
          \n    782         temp_file,\r\n    783         proxies=proxies,\r\n   \
          \ 784         resume_size=resume_size,\r\n    785         headers=headers,\r\
          \n    786     )\r\n    788 logger.info(\"storing %s in cache at %s\", url,\
          \ cache_path)\r\n    789 _chmod_and_replace(temp_file.name, cache_path)\r\
          \n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
          \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries)\r\
          \n    502 if resume_size > 0:\r\n    503     headers[\"Range\"] = \"bytes=%d-\"\
          \ % (resume_size,)\r\n--> 505 r = _request_wrapper(\r\n    506     method=\"\
          GET\",\r\n    507     url=url,\r\n    508     stream=True,\r\n    509  \
          \   proxies=proxies,\r\n    510     headers=headers,\r\n    511     timeout=timeout,\r\
          \n    512     max_retries=max_retries,\r\n    513 )\r\n    514 hf_raise_for_status(r)\r\
          \n    515 content_length = r.headers.get(\"Content-Length\")\r\n\r\nFile\
          \ /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
          \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
          \ timeout, follow_relative_redirects, **params)\r\n    439     return response\r\
          \n    441 # 3. Exponential backoff\r\n--> 442 return http_backoff(\r\n \
          \   443     method=method,\r\n    444     url=url,\r\n    445     max_retries=max_retries,\r\
          \n    446     base_wait_time=base_wait_time,\r\n    447     max_wait_time=max_wait_time,\r\
          \n    448     retry_on_exceptions=(ConnectTimeout, ProxyError),\r\n    449\
          \     retry_on_status_codes=(),\r\n    450     timeout=timeout,\r\n    451\
          \     **params,\r\n    452 )\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:129,\
          \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time,\
          \ retry_on_exceptions, retry_on_status_codes, **kwargs)\r\n    126     kwargs[\"\
          data\"].seek(io_obj_initial_pos)\r\n    128 # Perform request and return\
          \ if status_code is not in the retry list.\r\n--> 129 response = requests.request(method=method,\
          \ url=url, **kwargs)\r\n    130 if response.status_code not in retry_on_status_codes:\r\
          \n    131     return response\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/api.py:59,\
          \ in request(method, url, **kwargs)\r\n     55 # By using the 'with' statement\
          \ we are sure the session is closed, thus we\r\n     56 # avoid leaving\
          \ sockets open which can trigger a ResourceWarning in some\r\n     57 #\
          \ cases, and look like a memory leak in others.\r\n     58 with sessions.Session()\
          \ as session:\r\n---> 59     return session.request(method=method, url=url,\
          \ **kwargs)\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/sessions.py:587,\
          \ in Session.request(self, method, url, params, data, headers, cookies,\
          \ files, auth, timeout, allow_redirects, proxies, hooks, stream, verify,\
          \ cert, json)\r\n    582 send_kwargs = {\r\n    583     \"timeout\": timeout,\r\
          \n    584     \"allow_redirects\": allow_redirects,\r\n    585 }\r\n   \
          \ 586 send_kwargs.update(settings)\r\n--> 587 resp = self.send(prep, **send_kwargs)\r\
          \n    589 return resp\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/sessions.py:701,\
          \ in Session.send(self, request, **kwargs)\r\n    698 start = preferred_clock()\r\
          \n    700 # Send the request\r\n--> 701 r = adapter.send(request, **kwargs)\r\
          \n    703 # Total elapsed time of the request (approximately)\r\n    704\
          \ elapsed = preferred_clock() - start\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:547,\
          \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\r\
          \n    544             raise\r\n    546 except (ProtocolError, OSError) as\
          \ err:\r\n--> 547     raise ConnectionError(err, request=request)\r\n  \
          \  549 except MaxRetryError as e:\r\n    550     if isinstance(e.reason,\
          \ ConnectTimeoutError):\r\n    551         # TODO: Remove this in 3.0.0:\
          \ see #2811\r\n\r\nConnectionError: ('Connection aborted.', ConnectionResetError(104,\
          \ 'Connection reset by peer'))\r\n```"
        updatedAt: '2023-06-14T03:47:43.087Z'
      numEdits: 0
      reactions: []
    id: 6489385f24bcec4c08e9ab3f
    type: comment
  author: sunchao1212
  content: "When running my code this error appears.\r\nCode:\r\n```\r\nfrom sentence_transformers\
    \ import SentenceTransformer\r\nmodel = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\r\
    \n```\r\n\r\nTraceback:\r\n```\r\n---------------------------------------------------------------------------\r\
    \nConnectionResetError                      Traceback (most recent call last)\r\
    \nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703, in\
    \ HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\r\
    \n    702 # Make the request on the httplib connection object.\r\n--> 703 httplib_response\
    \ = self._make_request(\r\n    704     conn,\r\n    705     method,\r\n    706\
    \     url,\r\n    707     timeout=timeout_obj,\r\n    708     body=body,\r\n \
    \   709     headers=headers,\r\n    710     chunked=chunked,\r\n    711 )\r\n\
    \    713 # If we're going to release the connection in ``finally:``, then\r\n\
    \    714 # the response doesn't need to know about the connection. Otherwise\r\
    \n    715 # it will also try to release it and we'll have a double-release\r\n\
    \    716 # mess.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
    \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout, chunked,\
    \ **httplib_request_kw)\r\n    385 try:\r\n--> 386     self._validate_conn(conn)\r\
    \n    387 except (SocketTimeout, BaseSSLError) as e:\r\n    388     # Py2 raises\
    \ this as a BaseSSLError, Py3 raises it as socket timeout.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
    \ in HTTPSConnectionPool._validate_conn(self, conn)\r\n   1041 if not getattr(conn,\
    \ \"sock\", None):  # AppEngine might not have  `.sock`\r\n-> 1042     conn.connect()\r\
    \n   1044 if not conn.is_verified:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
    \ in HTTPSConnection.connect(self)\r\n    412     context.load_default_certs()\r\
    \n--> 414 self.sock = ssl_wrap_socket(\r\n    415     sock=conn,\r\n    416  \
    \   keyfile=self.key_file,\r\n    417     certfile=self.cert_file,\r\n    418\
    \     key_password=self.key_password,\r\n    419     ca_certs=self.ca_certs,\r\
    \n    420     ca_cert_dir=self.ca_cert_dir,\r\n    421     ca_cert_data=self.ca_cert_data,\r\
    \n    422     server_hostname=server_hostname,\r\n    423     ssl_context=context,\r\
    \n    424     tls_in_tls=tls_in_tls,\r\n    425 )\r\n    427 # If we're using\
    \ all defaults and the connection\r\n    428 # is TLSv1 or TLSv1.1 we throw a\
    \ DeprecationWarning\r\n    429 # for the host.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
    \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
    \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
    \ tls_in_tls)\r\n    448 if send_sni:\r\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\r\
    \n    450         sock, context, tls_in_tls, server_hostname=server_hostname\r\
    \n    451     )\r\n    452 else:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
    \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\r\n\
    \    492 if server_hostname:\r\n--> 493     return ssl_context.wrap_socket(sock,\
    \ server_hostname=server_hostname)\r\n    494 else:\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:501,\
    \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
    \ suppress_ragged_eofs, server_hostname, session)\r\n    495 def wrap_socket(self,\
    \ sock, server_side=False,\r\n    496                 do_handshake_on_connect=True,\r\
    \n    497                 suppress_ragged_eofs=True,\r\n    498              \
    \   server_hostname=None, session=None):\r\n    499     # SSLSocket class handles\
    \ server_hostname encoding before it calls\r\n    500     # ctx._wrap_socket()\r\
    \n--> 501     return self.sslsocket_class._create(\r\n    502         sock=sock,\r\
    \n    503         server_side=server_side,\r\n    504         do_handshake_on_connect=do_handshake_on_connect,\r\
    \n    505         suppress_ragged_eofs=suppress_ragged_eofs,\r\n    506      \
    \   server_hostname=server_hostname,\r\n    507         context=self,\r\n    508\
    \         session=session\r\n    509     )\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1041,\
    \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs,\
    \ server_hostname, context, session)\r\n   1040             raise ValueError(\"\
    do_handshake_on_connect should not be specified for non-blocking sockets\")\r\n\
    -> 1041         self.do_handshake()\r\n   1042 except (OSError, ValueError):\r\
    \n\r\nFile /home/pai/lib/python3.9/ssl.py:1310, in SSLSocket.do_handshake(self,\
    \ block)\r\n   1309         self.settimeout(None)\r\n-> 1310     self._sslobj.do_handshake()\r\
    \n   1311 finally:\r\n\r\nConnectionResetError: [Errno 104] Connection reset by\
    \ peer\r\n\r\nDuring handling of the above exception, another exception occurred:\r\
    \n\r\nProtocolError                             Traceback (most recent call last)\r\
    \nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:489, in HTTPAdapter.send(self,\
    \ request, stream, timeout, verify, cert, proxies)\r\n    488 if not chunked:\r\
    \n--> 489     resp = conn.urlopen(\r\n    490         method=request.method,\r\
    \n    491         url=url,\r\n    492         body=request.body,\r\n    493  \
    \       headers=request.headers,\r\n    494         redirect=False,\r\n    495\
    \         assert_same_host=False,\r\n    496         preload_content=False,\r\n\
    \    497         decode_content=False,\r\n    498         retries=self.max_retries,\r\
    \n    499         timeout=timeout,\r\n    500     )\r\n    502 # Send the request.\r\
    \n    503 else:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:787,\
    \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\r\
    \n    785     e = ProtocolError(\"Connection aborted.\", e)\r\n--> 787 retries\
    \ = retries.increment(\r\n    788     method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\r\
    \n    789 )\r\n    790 retries.sleep()\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/retry.py:550,\
    \ in Retry.increment(self, method, url, response, error, _pool, _stacktrace)\r\
    \n    549 if read is False or not self._is_method_retryable(method):\r\n--> 550\
    \     raise six.reraise(type(error), error, _stacktrace)\r\n    551 elif read\
    \ is not None:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/packages/six.py:769,\
    \ in reraise(tp, value, tb)\r\n    768 if value.__traceback__ is not tb:\r\n-->\
    \ 769     raise value.with_traceback(tb)\r\n    770 raise value\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:703,\
    \ in HTTPConnectionPool.urlopen(self, method, url, body, headers, retries, redirect,\
    \ assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\r\
    \n    702 # Make the request on the httplib connection object.\r\n--> 703 httplib_response\
    \ = self._make_request(\r\n    704     conn,\r\n    705     method,\r\n    706\
    \     url,\r\n    707     timeout=timeout_obj,\r\n    708     body=body,\r\n \
    \   709     headers=headers,\r\n    710     chunked=chunked,\r\n    711 )\r\n\
    \    713 # If we're going to release the connection in ``finally:``, then\r\n\
    \    714 # the response doesn't need to know about the connection. Otherwise\r\
    \n    715 # it will also try to release it and we'll have a double-release\r\n\
    \    716 # mess.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:386,\
    \ in HTTPConnectionPool._make_request(self, conn, method, url, timeout, chunked,\
    \ **httplib_request_kw)\r\n    385 try:\r\n--> 386     self._validate_conn(conn)\r\
    \n    387 except (SocketTimeout, BaseSSLError) as e:\r\n    388     # Py2 raises\
    \ this as a BaseSSLError, Py3 raises it as socket timeout.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connectionpool.py:1042,\
    \ in HTTPSConnectionPool._validate_conn(self, conn)\r\n   1041 if not getattr(conn,\
    \ \"sock\", None):  # AppEngine might not have  `.sock`\r\n-> 1042     conn.connect()\r\
    \n   1044 if not conn.is_verified:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/connection.py:414,\
    \ in HTTPSConnection.connect(self)\r\n    412     context.load_default_certs()\r\
    \n--> 414 self.sock = ssl_wrap_socket(\r\n    415     sock=conn,\r\n    416  \
    \   keyfile=self.key_file,\r\n    417     certfile=self.cert_file,\r\n    418\
    \     key_password=self.key_password,\r\n    419     ca_certs=self.ca_certs,\r\
    \n    420     ca_cert_dir=self.ca_cert_dir,\r\n    421     ca_cert_data=self.ca_cert_data,\r\
    \n    422     server_hostname=server_hostname,\r\n    423     ssl_context=context,\r\
    \n    424     tls_in_tls=tls_in_tls,\r\n    425 )\r\n    427 # If we're using\
    \ all defaults and the connection\r\n    428 # is TLSv1 or TLSv1.1 we throw a\
    \ DeprecationWarning\r\n    429 # for the host.\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:449,\
    \ in ssl_wrap_socket(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname,\
    \ ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data,\
    \ tls_in_tls)\r\n    448 if send_sni:\r\n--> 449     ssl_sock = _ssl_wrap_socket_impl(\r\
    \n    450         sock, context, tls_in_tls, server_hostname=server_hostname\r\
    \n    451     )\r\n    452 else:\r\n\r\nFile /home/pai/lib/python3.9/site-packages/urllib3/util/ssl_.py:493,\
    \ in _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname)\r\n\
    \    492 if server_hostname:\r\n--> 493     return ssl_context.wrap_socket(sock,\
    \ server_hostname=server_hostname)\r\n    494 else:\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:501,\
    \ in SSLContext.wrap_socket(self, sock, server_side, do_handshake_on_connect,\
    \ suppress_ragged_eofs, server_hostname, session)\r\n    495 def wrap_socket(self,\
    \ sock, server_side=False,\r\n    496                 do_handshake_on_connect=True,\r\
    \n    497                 suppress_ragged_eofs=True,\r\n    498              \
    \   server_hostname=None, session=None):\r\n    499     # SSLSocket class handles\
    \ server_hostname encoding before it calls\r\n    500     # ctx._wrap_socket()\r\
    \n--> 501     return self.sslsocket_class._create(\r\n    502         sock=sock,\r\
    \n    503         server_side=server_side,\r\n    504         do_handshake_on_connect=do_handshake_on_connect,\r\
    \n    505         suppress_ragged_eofs=suppress_ragged_eofs,\r\n    506      \
    \   server_hostname=server_hostname,\r\n    507         context=self,\r\n    508\
    \         session=session\r\n    509     )\r\n\r\nFile /home/pai/lib/python3.9/ssl.py:1041,\
    \ in SSLSocket._create(cls, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs,\
    \ server_hostname, context, session)\r\n   1040             raise ValueError(\"\
    do_handshake_on_connect should not be specified for non-blocking sockets\")\r\n\
    -> 1041         self.do_handshake()\r\n   1042 except (OSError, ValueError):\r\
    \n\r\nFile /home/pai/lib/python3.9/ssl.py:1310, in SSLSocket.do_handshake(self,\
    \ block)\r\n   1309         self.settimeout(None)\r\n-> 1310     self._sslobj.do_handshake()\r\
    \n   1311 finally:\r\n\r\nProtocolError: ('Connection aborted.', ConnectionResetError(104,\
    \ 'Connection reset by peer'))\r\n\r\nDuring handling of the above exception,\
    \ another exception occurred:\r\n\r\nConnectionError                         \
    \  Traceback (most recent call last)\r\nCell In[3], line 2\r\n      1 from sentence_transformers\
    \ import SentenceTransformer\r\n----> 2 model = SentenceTransformer('DMetaSoul/sbert-chinese-general-v2')\r\
    \n\r\nFile /home/pai/lib/python3.9/site-packages/sentence_transformers/SentenceTransformer.py:87,\
    \ in SentenceTransformer.__init__(self, model_name_or_path, modules, device, cache_folder,\
    \ use_auth_token)\r\n     83     model_path = os.path.join(cache_folder, model_name_or_path.replace(\"\
    /\", \"_\"))\r\n     85     if not os.path.exists(os.path.join(model_path, 'modules.json')):\r\
    \n     86         # Download from hub with caching\r\n---> 87         snapshot_download(model_name_or_path,\r\
    \n     88                             cache_dir=cache_folder,\r\n     89     \
    \                        library_name='sentence-transformers',\r\n     90    \
    \                         library_version=__version__,\r\n     91            \
    \                 ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\r\
    \n     92                             use_auth_token=use_auth_token)\r\n     94\
    \ if os.path.exists(os.path.join(model_path, 'modules.json')):    #Load as SentenceTransformer\
    \ model\r\n     95     modules = self._load_sbert_model(model_path)\r\n\r\nFile\
    \ /home/pai/lib/python3.9/site-packages/sentence_transformers/util.py:491, in\
    \ snapshot_download(repo_id, revision, cache_dir, library_name, library_version,\
    \ user_agent, ignore_files, use_auth_token)\r\n    486 if version.parse(huggingface_hub.__version__)\
    \ >= version.parse(\"0.8.1\"):\r\n    487     # huggingface_hub v0.8.1 introduces\
    \ a new cache layout. We sill use a manual layout\r\n    488     # And need to\
    \ pass legacy_cache_layout=True to avoid that a warning will be printed\r\n  \
    \  489     cached_download_args['legacy_cache_layout'] = True\r\n--> 491 path\
    \ = cached_download(**cached_download_args)\r\n    493 if os.path.exists(path\
    \ + \".lock\"):\r\n    494     os.remove(path + \".lock\")\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_validators.py:120,\
    \ in validate_hf_hub_args.<locals>._inner_fn(*args, **kwargs)\r\n    117 if check_use_auth_token:\r\
    \n    118     kwargs = smoothly_deprecate_use_auth_token(fn_name=fn.__name__,\
    \ has_token=has_token, kwargs=kwargs)\r\n--> 120 return fn(*args, **kwargs)\r\n\
    \r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:780,\
    \ in cached_download(url, library_name, library_version, cache_dir, user_agent,\
    \ force_download, force_filename, proxies, etag_timeout, resume_download, token,\
    \ local_files_only, legacy_cache_layout)\r\n    777 with temp_file_manager() as\
    \ temp_file:\r\n    778     logger.info(\"downloading %s to %s\", url, temp_file.name)\r\
    \n--> 780     http_get(\r\n    781         url_to_download,\r\n    782       \
    \  temp_file,\r\n    783         proxies=proxies,\r\n    784         resume_size=resume_size,\r\
    \n    785         headers=headers,\r\n    786     )\r\n    788 logger.info(\"\
    storing %s in cache at %s\", url, cache_path)\r\n    789 _chmod_and_replace(temp_file.name,\
    \ cache_path)\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:505,\
    \ in http_get(url, temp_file, proxies, resume_size, headers, timeout, max_retries)\r\
    \n    502 if resume_size > 0:\r\n    503     headers[\"Range\"] = \"bytes=%d-\"\
    \ % (resume_size,)\r\n--> 505 r = _request_wrapper(\r\n    506     method=\"GET\"\
    ,\r\n    507     url=url,\r\n    508     stream=True,\r\n    509     proxies=proxies,\r\
    \n    510     headers=headers,\r\n    511     timeout=timeout,\r\n    512    \
    \ max_retries=max_retries,\r\n    513 )\r\n    514 hf_raise_for_status(r)\r\n\
    \    515 content_length = r.headers.get(\"Content-Length\")\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/file_download.py:442,\
    \ in _request_wrapper(method, url, max_retries, base_wait_time, max_wait_time,\
    \ timeout, follow_relative_redirects, **params)\r\n    439     return response\r\
    \n    441 # 3. Exponential backoff\r\n--> 442 return http_backoff(\r\n    443\
    \     method=method,\r\n    444     url=url,\r\n    445     max_retries=max_retries,\r\
    \n    446     base_wait_time=base_wait_time,\r\n    447     max_wait_time=max_wait_time,\r\
    \n    448     retry_on_exceptions=(ConnectTimeout, ProxyError),\r\n    449   \
    \  retry_on_status_codes=(),\r\n    450     timeout=timeout,\r\n    451     **params,\r\
    \n    452 )\r\n\r\nFile /home/pai/lib/python3.9/site-packages/huggingface_hub/utils/_http.py:129,\
    \ in http_backoff(method, url, max_retries, base_wait_time, max_wait_time, retry_on_exceptions,\
    \ retry_on_status_codes, **kwargs)\r\n    126     kwargs[\"data\"].seek(io_obj_initial_pos)\r\
    \n    128 # Perform request and return if status_code is not in the retry list.\r\
    \n--> 129 response = requests.request(method=method, url=url, **kwargs)\r\n  \
    \  130 if response.status_code not in retry_on_status_codes:\r\n    131     return\
    \ response\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/api.py:59,\
    \ in request(method, url, **kwargs)\r\n     55 # By using the 'with' statement\
    \ we are sure the session is closed, thus we\r\n     56 # avoid leaving sockets\
    \ open which can trigger a ResourceWarning in some\r\n     57 # cases, and look\
    \ like a memory leak in others.\r\n     58 with sessions.Session() as session:\r\
    \n---> 59     return session.request(method=method, url=url, **kwargs)\r\n\r\n\
    File /home/pai/lib/python3.9/site-packages/requests/sessions.py:587, in Session.request(self,\
    \ method, url, params, data, headers, cookies, files, auth, timeout, allow_redirects,\
    \ proxies, hooks, stream, verify, cert, json)\r\n    582 send_kwargs = {\r\n \
    \   583     \"timeout\": timeout,\r\n    584     \"allow_redirects\": allow_redirects,\r\
    \n    585 }\r\n    586 send_kwargs.update(settings)\r\n--> 587 resp = self.send(prep,\
    \ **send_kwargs)\r\n    589 return resp\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/sessions.py:701,\
    \ in Session.send(self, request, **kwargs)\r\n    698 start = preferred_clock()\r\
    \n    700 # Send the request\r\n--> 701 r = adapter.send(request, **kwargs)\r\n\
    \    703 # Total elapsed time of the request (approximately)\r\n    704 elapsed\
    \ = preferred_clock() - start\r\n\r\nFile /home/pai/lib/python3.9/site-packages/requests/adapters.py:547,\
    \ in HTTPAdapter.send(self, request, stream, timeout, verify, cert, proxies)\r\
    \n    544             raise\r\n    546 except (ProtocolError, OSError) as err:\r\
    \n--> 547     raise ConnectionError(err, request=request)\r\n    549 except MaxRetryError\
    \ as e:\r\n    550     if isinstance(e.reason, ConnectTimeoutError):\r\n    551\
    \         # TODO: Remove this in 3.0.0: see #2811\r\n\r\nConnectionError: ('Connection\
    \ aborted.', ConnectionResetError(104, 'Connection reset by peer'))\r\n```"
  created_at: 2023-06-14 02:47:43+00:00
  edited: false
  hidden: false
  id: 6489385f24bcec4c08e9ab3f
  type: comment
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/64708fff3601bb7b0665ced3/2kSMChrKol4ccgLYJN_vt.jpeg?w=200&h=200&f=face
      fullname: SunqingXuan
      isHf: false
      isOrgMember: true
      isOwner: false
      isPro: false
      name: Howardxuan
      type: user
    createdAt: '2023-06-14T03:58:03.000Z'
    data:
      edited: false
      editors:
      - Howardxuan
      hidden: false
      identifiedLanguage:
        language: en
        probability: 0.9695244431495667
      isReport: false
      latest:
        author:
          avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/64708fff3601bb7b0665ced3/2kSMChrKol4ccgLYJN_vt.jpeg?w=200&h=200&f=face
          fullname: SunqingXuan
          isHf: false
          isPro: false
          name: Howardxuan
          type: user
        html: '<p>This error usually indicates that your program attempted to connect
          to a remote server or website, but the connection was aborted by the other
          host. This may be caused by network issues, firewalls, proxy servers, etc.It
          is also possible that requests are too frequent, resulting in requests being
          rejected.You can try again later</p>

          '
        raw: This error usually indicates that your program attempted to connect to
          a remote server or website, but the connection was aborted by the other
          host. This may be caused by network issues, firewalls, proxy servers, etc.It
          is also possible that requests are too frequent, resulting in requests being
          rejected.You can try again later
        updatedAt: '2023-06-14T03:58:03.507Z'
      numEdits: 0
      reactions:
      - count: 1
        reaction: "\U0001F44D"
        users:
        - MokaHR
    id: 64893acb41515affad83b639
    type: comment
  author: Howardxuan
  content: This error usually indicates that your program attempted to connect to
    a remote server or website, but the connection was aborted by the other host.
    This may be caused by network issues, firewalls, proxy servers, etc.It is also
    possible that requests are too frequent, resulting in requests being rejected.You
    can try again later
  created_at: 2023-06-14 02:58:03+00:00
  edited: false
  hidden: false
  id: 64893acb41515affad83b639
  type: comment
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/noauth/NbjjEhhwMdzDz-jdOrwdu.png?w=200&h=200&f=face
      fullname: Moka HR SaSS
      isHf: false
      isOrgMember: true
      isOwner: false
      isPro: false
      name: MokaHR
      type: user
    createdAt: '2023-06-14T03:58:28.000Z'
    data:
      edited: false
      editors:
      - MokaHR
      hidden: false
      identifiedLanguage:
        language: en
        probability: 0.9662546515464783
      isReport: false
      latest:
        author:
          avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/noauth/NbjjEhhwMdzDz-jdOrwdu.png?w=200&h=200&f=face
          fullname: Moka HR SaSS
          isHf: false
          isPro: false
          name: MokaHR
          type: user
        html: '<p>This is due to a network issue, and downloading the model requires
          you to be able to communicate with huggingface''s server</p>

          '
        raw: This is due to a network issue, and downloading the model requires you
          to be able to communicate with huggingface's server
        updatedAt: '2023-06-14T03:58:28.462Z'
      numEdits: 0
      reactions: []
    id: 64893ae4e9d8672ffde86532
    type: comment
  author: MokaHR
  content: This is due to a network issue, and downloading the model requires you
    to be able to communicate with huggingface's server
  created_at: 2023-06-14 02:58:28+00:00
  edited: false
  hidden: false
  id: 64893ae4e9d8672ffde86532
  type: comment
- !!python/object:huggingface_hub.community.DiscussionStatusChange
  _event:
    author:
      avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/noauth/NbjjEhhwMdzDz-jdOrwdu.png?w=200&h=200&f=face
      fullname: Moka HR SaSS
      isHf: false
      isOrgMember: true
      isOwner: false
      isPro: false
      name: MokaHR
      type: user
    createdAt: '2023-06-14T11:13:21.000Z'
    data:
      status: closed
    id: 6489a0d1d0b2fd1f32975d58
    type: status-change
  author: MokaHR
  created_at: 2023-06-14 10:13:21+00:00
  id: 6489a0d1d0b2fd1f32975d58
  new_status: closed
  type: status-change
is_pull_request: false
merge_commit_oid: null
num: 3
repo_id: moka-ai/m3e-base
repo_type: model
status: closed
target_branch: null
title: 'ConnectionError: (''Connection aborted.'', ConnectionResetError(104, ''Connection
  reset by peer''))'
