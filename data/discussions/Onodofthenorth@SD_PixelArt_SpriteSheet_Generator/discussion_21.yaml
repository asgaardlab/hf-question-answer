!!python/object:huggingface_hub.community.DiscussionWithDetails
author: Edwardelric
conflicting_files: null
created_at: 2023-03-24 01:40:41+00:00
diff: null
endpoint: https://huggingface.co
events:
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: /avatars/ff0725e948ef669d1381b54505ef49c9.svg
      fullname: zuoxian chen
      isHf: false
      isOrgMember: false
      isOwner: false
      isPro: false
      name: Edwardelric
      type: user
    createdAt: '2023-03-24T02:40:41.000Z'
    data:
      edited: false
      editors:
      - Edwardelric
      hidden: false
      isReport: false
      latest:
        author:
          avatarUrl: /avatars/ff0725e948ef669d1381b54505ef49c9.svg
          fullname: zuoxian chen
          isHf: false
          isPro: false
          name: Edwardelric
          type: user
        html: '<p>Hello,<br>I tried to train my own model with stardrew valley characters,
          but found that images are too tiny, could u tell how to preprocess your
          training data?</p>

          '
        raw: "Hello,\r\nI tried to train my own model with stardrew valley characters,\
          \ but found that images are too tiny, could u tell how to preprocess your\
          \ training data?"
        updatedAt: '2023-03-24T02:40:41.720Z'
      numEdits: 0
      reactions: []
    id: 641d0da9353524fe41f0f8af
    type: comment
  author: Edwardelric
  content: "Hello,\r\nI tried to train my own model with stardrew valley characters,\
    \ but found that images are too tiny, could u tell how to preprocess your training\
    \ data?"
  created_at: 2023-03-24 01:40:41+00:00
  edited: false
  hidden: false
  id: 641d0da9353524fe41f0f8af
  type: comment
- !!python/object:huggingface_hub.community.DiscussionComment
  _event:
    author:
      avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/63028bc42db53f7d9f38dadb/BwfqqXVdqvvO0YOlHw8-L.jpeg?w=200&h=200&f=face
      fullname: OnodOfTheNorth
      isHf: false
      isOrgMember: false
      isOwner: true
      isPro: false
      name: Onodofthenorth
      type: user
    createdAt: '2023-03-31T21:20:21.000Z'
    data:
      edited: true
      editors:
      - Onodofthenorth
      hidden: false
      isReport: false
      latest:
        author:
          avatarUrl: https://aeiljuispo.cloudimg.io/v7/https://cdn-uploads.huggingface.co/production/uploads/63028bc42db53f7d9f38dadb/BwfqqXVdqvvO0YOlHw8-L.jpeg?w=200&h=200&f=face
          fullname: OnodOfTheNorth
          isHf: false
          isPro: false
          name: Onodofthenorth
          type: user
        html: "<p>yeah sure! I lost most of my work on this project in an unfortunate\
          \ accident while upgrading my storage setup. but here is a basic script\
          \ that was pretty close to what I had from what I can remember. Also I didn't\
          \ use stardew valley official files as these are not licensed for use in\
          \ this way. I used various stardew valley mods which are free for reuse.\
          \ that being said I cannot control how you choose to apply these technologies.\
          \ so keep in mind the specific values for height and width will need to\
          \ be adjusted to fit the input data. I also just whipped this up quickly\
          \ and probably made mistakes. I haven't tested what I'm sending and I do\
          \ not have the time right now to recollect my data to test it; so don't\
          \ be surprised if you have to do some fiddling. </p>\n<p>make sure you install\
          \ Pillow </p>\n<p>I'm pretty sure the pip is </p>\n<p>pip install Pillow</p>\n\
          <pre><code>import os\nfrom PIL import Image\n\n\ndef process_image(input_path,\
          \ output_path, image_number):\n    # Load the input image\n    image = Image.open(input_path)\n\
          \n    # Create a plain grey background of 512x512 pixels\n    background\
          \ = Image.new(\"RGBA\", (512, 512), (128, 128, 128, 255))\n\n    # Define\
          \ the dimensions of the extracted area (32x64 pixels)\n    width, height\
          \ = 32, 64\n\n    # Calculate the resized dimensions to fit the 512x512\
          \ background\n    resized_width, resized_height = 512 // 4, 512 // 1\n\n\
          \    # Iterate through 4 rows of the image ( if you want to do the first\
          \ 4 views. I found with most of my data I could just do the first 3 and\
          \ mirror one of the side views. play around and find what works for you.\
          \ )\n    for row in range(4):\n        # Calculate the top left corner coordinates\
          \ of the current row\n        left, top = 0, row * height\n\n        # Define\
          \ the area to be cropped from the input image\n        area = (left, top,\
          \ left + width, top + height)\n\n        # Crop and resize the extracted\
          \ area. Use nearest neighbor. I think this is the right call to resize but\
          \ if it doesn't work just check pillows docs and it should be in there.\n\
          \        extracted = image.crop(area)\n        resized = extracted.resize((resized_width,\
          \ resized_height), Image.NEAREST)\n\n        # Create a plain grey background\
          \ of 512x512 pixels. It doesn't have to be this specific grey or grey at\
          \ all but make sure whatever you choose has enough contrast from any of\
          \ the colors in your data palette.\n        background = Image.new(\"RGBA\"\
          , (512, 512), (128, 128, 128, 255))\n\n        # Paste the resized area\
          \ onto the background\n        background.paste(resized, (row * resized_width,\
          \ 0))\n\n        # Determine the output filename based on the row number.\
          \ i cant remember the order of the views in the file but this is working\
          \ from top to bottom so name them however you want so you can call specific\
          \ views\n        # durring inference (image generation).\n        view =\
          \ \"\"\n        if row == 0:\n            view = \"front\"\n        elif\
          \ row == 1:\n            view = \"back\"\n        elif row == 2:\n     \
          \       view = \"left\"\n        elif row == 3:\n            view = \"right\"\
          \n\n        output_filename = f\"{view}{image_number}.png\"\n        output_path\
          \ = os.path.join(output_path, output_filename)\n\n        # Save the final\
          \ image to the output path\n        background.save(output_path, \"PNG\"\
          )\n        print(f\"Processed: {input_path} -&gt; {output_path}\")\n\n\n\
          def main():\n    input_folder = \"path/to/your/input_folder\"\n    output_folder\
          \ = \"path/to/your/output_folder\"\n\n    # this just ensures your output\
          \ folder exists if not it will create one\n    if not os.path.exists(output_folder):\n\
          \        os.makedirs(output_folder)\n\n    # Initialize the image number\
          \ counter variable will keep track of how many images you've iterated through\
          \ and use this to add (x) where x is the iteration count. this allows you\
          \ to have the views have the same name\n    # in the training data without\
          \ overwriting.\n    image_number = 0\n\n    # Iterate through the files\
          \ in the input folder\n    for filename in os.listdir(input_folder):\n \
          \       if filename.endswith(\".png\"):\n            input_path = os.path.join(input_folder,\
          \ filename)\n            process_image(input_path, output_folder, image_number)\n\
          \            image_number += 1\n\n\nif __name__ == \"__main__\":\n    main()\n\
          </code></pre>\n"
        raw: "yeah sure! I lost most of my work on this project in an unfortunate\
          \ accident while upgrading my storage setup. but here is a basic script\
          \ that was pretty close to what I had from what I can remember. Also I didn't\
          \ use stardew valley official files as these are not licensed for use in\
          \ this way. I used various stardew valley mods which are free for reuse.\
          \ that being said I cannot control how you choose to apply these technologies.\
          \ so keep in mind the specific values for height and width will need to\
          \ be adjusted to fit the input data. I also just whipped this up quickly\
          \ and probably made mistakes. I haven't tested what I'm sending and I do\
          \ not have the time right now to recollect my data to test it; so don't\
          \ be surprised if you have to do some fiddling. \n\nmake sure you install\
          \ Pillow \n\nI'm pretty sure the pip is \n\npip install Pillow\n\n\n   \
          \ import os\n    from PIL import Image\n\n\n    def process_image(input_path,\
          \ output_path, image_number):\n        # Load the input image\n        image\
          \ = Image.open(input_path)\n\n        # Create a plain grey background of\
          \ 512x512 pixels\n        background = Image.new(\"RGBA\", (512, 512), (128,\
          \ 128, 128, 255))\n\n        # Define the dimensions of the extracted area\
          \ (32x64 pixels)\n        width, height = 32, 64\n\n        # Calculate\
          \ the resized dimensions to fit the 512x512 background\n        resized_width,\
          \ resized_height = 512 // 4, 512 // 1\n\n        # Iterate through 4 rows\
          \ of the image ( if you want to do the first 4 views. I found with most\
          \ of my data I could just do the first 3 and mirror one of the side views.\
          \ play around and find what works for you. )\n        for row in range(4):\n\
          \            # Calculate the top left corner coordinates of the current\
          \ row\n            left, top = 0, row * height\n\n            # Define the\
          \ area to be cropped from the input image\n            area = (left, top,\
          \ left + width, top + height)\n\n            # Crop and resize the extracted\
          \ area. Use nearest neighbor. I think this is the right call to resize but\
          \ if it doesn't work just check pillows docs and it should be in there.\n\
          \            extracted = image.crop(area)\n            resized = extracted.resize((resized_width,\
          \ resized_height), Image.NEAREST)\n\n            # Create a plain grey background\
          \ of 512x512 pixels. It doesn't have to be this specific grey or grey at\
          \ all but make sure whatever you choose has enough contrast from any of\
          \ the colors in your data palette.\n            background = Image.new(\"\
          RGBA\", (512, 512), (128, 128, 128, 255))\n\n            # Paste the resized\
          \ area onto the background\n            background.paste(resized, (row *\
          \ resized_width, 0))\n\n            # Determine the output filename based\
          \ on the row number. i cant remember the order of the views in the file\
          \ but this is working from top to bottom so name them however you want so\
          \ you can call specific views\n            # durring inference (image generation).\n\
          \            view = \"\"\n            if row == 0:\n                view\
          \ = \"front\"\n            elif row == 1:\n                view = \"back\"\
          \n            elif row == 2:\n                view = \"left\"\n        \
          \    elif row == 3:\n                view = \"right\"\n\n            output_filename\
          \ = f\"{view}{image_number}.png\"\n            output_path = os.path.join(output_path,\
          \ output_filename)\n\n            # Save the final image to the output path\n\
          \            background.save(output_path, \"PNG\")\n            print(f\"\
          Processed: {input_path} -> {output_path}\")\n\n\n    def main():\n     \
          \   input_folder = \"path/to/your/input_folder\"\n        output_folder\
          \ = \"path/to/your/output_folder\"\n\n        # this just ensures your output\
          \ folder exists if not it will create one\n        if not os.path.exists(output_folder):\n\
          \            os.makedirs(output_folder)\n\n        # Initialize the image\
          \ number counter variable will keep track of how many images you've iterated\
          \ through and use this to add (x) where x is the iteration count. this allows\
          \ you to have the views have the same name\n        # in the training data\
          \ without overwriting.\n        image_number = 0\n\n        # Iterate through\
          \ the files in the input folder\n        for filename in os.listdir(input_folder):\n\
          \            if filename.endswith(\".png\"):\n                input_path\
          \ = os.path.join(input_folder, filename)\n                process_image(input_path,\
          \ output_folder, image_number)\n                image_number += 1\n\n\n\
          \    if __name__ == \"__main__\":\n        main()"
        updatedAt: '2023-03-31T21:24:01.895Z'
      numEdits: 2
      reactions: []
    id: 64274e952f268b4f57cc9333
    type: comment
  author: Onodofthenorth
  content: "yeah sure! I lost most of my work on this project in an unfortunate accident\
    \ while upgrading my storage setup. but here is a basic script that was pretty\
    \ close to what I had from what I can remember. Also I didn't use stardew valley\
    \ official files as these are not licensed for use in this way. I used various\
    \ stardew valley mods which are free for reuse. that being said I cannot control\
    \ how you choose to apply these technologies. so keep in mind the specific values\
    \ for height and width will need to be adjusted to fit the input data. I also\
    \ just whipped this up quickly and probably made mistakes. I haven't tested what\
    \ I'm sending and I do not have the time right now to recollect my data to test\
    \ it; so don't be surprised if you have to do some fiddling. \n\nmake sure you\
    \ install Pillow \n\nI'm pretty sure the pip is \n\npip install Pillow\n\n\n \
    \   import os\n    from PIL import Image\n\n\n    def process_image(input_path,\
    \ output_path, image_number):\n        # Load the input image\n        image =\
    \ Image.open(input_path)\n\n        # Create a plain grey background of 512x512\
    \ pixels\n        background = Image.new(\"RGBA\", (512, 512), (128, 128, 128,\
    \ 255))\n\n        # Define the dimensions of the extracted area (32x64 pixels)\n\
    \        width, height = 32, 64\n\n        # Calculate the resized dimensions\
    \ to fit the 512x512 background\n        resized_width, resized_height = 512 //\
    \ 4, 512 // 1\n\n        # Iterate through 4 rows of the image ( if you want to\
    \ do the first 4 views. I found with most of my data I could just do the first\
    \ 3 and mirror one of the side views. play around and find what works for you.\
    \ )\n        for row in range(4):\n            # Calculate the top left corner\
    \ coordinates of the current row\n            left, top = 0, row * height\n\n\
    \            # Define the area to be cropped from the input image\n          \
    \  area = (left, top, left + width, top + height)\n\n            # Crop and resize\
    \ the extracted area. Use nearest neighbor. I think this is the right call to\
    \ resize but if it doesn't work just check pillows docs and it should be in there.\n\
    \            extracted = image.crop(area)\n            resized = extracted.resize((resized_width,\
    \ resized_height), Image.NEAREST)\n\n            # Create a plain grey background\
    \ of 512x512 pixels. It doesn't have to be this specific grey or grey at all but\
    \ make sure whatever you choose has enough contrast from any of the colors in\
    \ your data palette.\n            background = Image.new(\"RGBA\", (512, 512),\
    \ (128, 128, 128, 255))\n\n            # Paste the resized area onto the background\n\
    \            background.paste(resized, (row * resized_width, 0))\n\n         \
    \   # Determine the output filename based on the row number. i cant remember the\
    \ order of the views in the file but this is working from top to bottom so name\
    \ them however you want so you can call specific views\n            # durring\
    \ inference (image generation).\n            view = \"\"\n            if row ==\
    \ 0:\n                view = \"front\"\n            elif row == 1:\n         \
    \       view = \"back\"\n            elif row == 2:\n                view = \"\
    left\"\n            elif row == 3:\n                view = \"right\"\n\n     \
    \       output_filename = f\"{view}{image_number}.png\"\n            output_path\
    \ = os.path.join(output_path, output_filename)\n\n            # Save the final\
    \ image to the output path\n            background.save(output_path, \"PNG\")\n\
    \            print(f\"Processed: {input_path} -> {output_path}\")\n\n\n    def\
    \ main():\n        input_folder = \"path/to/your/input_folder\"\n        output_folder\
    \ = \"path/to/your/output_folder\"\n\n        # this just ensures your output\
    \ folder exists if not it will create one\n        if not os.path.exists(output_folder):\n\
    \            os.makedirs(output_folder)\n\n        # Initialize the image number\
    \ counter variable will keep track of how many images you've iterated through\
    \ and use this to add (x) where x is the iteration count. this allows you to have\
    \ the views have the same name\n        # in the training data without overwriting.\n\
    \        image_number = 0\n\n        # Iterate through the files in the input\
    \ folder\n        for filename in os.listdir(input_folder):\n            if filename.endswith(\"\
    .png\"):\n                input_path = os.path.join(input_folder, filename)\n\
    \                process_image(input_path, output_folder, image_number)\n    \
    \            image_number += 1\n\n\n    if __name__ == \"__main__\":\n       \
    \ main()"
  created_at: 2023-03-31 20:20:21+00:00
  edited: true
  hidden: false
  id: 64274e952f268b4f57cc9333
  type: comment
is_pull_request: false
merge_commit_oid: null
num: 21
repo_id: Onodofthenorth/SD_PixelArt_SpriteSheet_Generator
repo_type: model
status: open
target_branch: null
title: Train image question
